{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { Instrument } from \"../instrument/Instrument.js\";\nimport { timeRange } from \"../core/util/Decorator.js\";\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport class Monophonic extends Instrument {\n  constructor() {\n    const options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n    super(options);\n    this.portamento = options.portamento;\n    this.onsilence = options.onsilence;\n  }\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      detune: 0,\n      onsilence: noOp,\n      portamento: 0\n    });\n  }\n  /**\n   * Trigger the attack of the note optionally with a given velocity.\n   * @param  note The note to trigger.\n   * @param  time When the note should start.\n   * @param  velocity The velocity determines how \"loud\" the note will be.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * // trigger the note a half second from now at half velocity\n   * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n   */\n  triggerAttack(note, time, velocity = 1) {\n    this.log(\"triggerAttack\", note, time, velocity);\n    const seconds = this.toSeconds(time);\n    this._triggerEnvelopeAttack(seconds, velocity);\n    this.setNote(note, seconds);\n    return this;\n  }\n  /**\n   * Trigger the release portion of the envelope.\n   * @param  time If no time is given, the release happens immediately.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * synth.triggerAttack(\"C4\");\n   * // trigger the release a second from now\n   * synth.triggerRelease(\"+1\");\n   */\n  triggerRelease(time) {\n    this.log(\"triggerRelease\", time);\n    const seconds = this.toSeconds(time);\n    this._triggerEnvelopeRelease(seconds);\n    return this;\n  }\n  /**\n   * Set the note at the given time. If no time is given, the note\n   * will set immediately.\n   * @param note The note to change to.\n   * @param  time The time when the note should be set.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * synth.triggerAttack(\"C4\");\n   * // change to F#6 in one quarter note from now.\n   * synth.setNote(\"F#6\", \"+4n\");\n   */\n  setNote(note, time) {\n    const computedTime = this.toSeconds(time);\n    const computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n    if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n      const portTime = this.toSeconds(this.portamento);\n      this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n    } else {\n      this.frequency.setValueAtTime(computedFrequency, computedTime);\n    }\n    return this;\n  }\n}\n__decorate([timeRange(0)], Monophonic.prototype, \"portamento\", void 0);","map":{"version":3,"names":["FrequencyClass","optionsFromArguments","noOp","Instrument","timeRange","Monophonic","constructor","options","getDefaults","arguments","portamento","onsilence","Object","assign","detune","triggerAttack","note","time","velocity","log","seconds","toSeconds","_triggerEnvelopeAttack","setNote","triggerRelease","_triggerEnvelopeRelease","computedTime","computedFrequency","toFrequency","getLevelAtTime","portTime","frequency","exponentialRampTo","setValueAtTime","__decorate"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/instrument/Monophonic.ts"],"sourcesContent":["import { FrequencyClass } from \"../core/type/Frequency.js\";\nimport {\n\tCents,\n\tFrequency,\n\tNormalRange,\n\tSeconds,\n\tTime,\n} from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { timeRange } from \"../core/util/Decorator.js\";\n\ntype onSilenceCallback = (instrument: Monophonic<any>) => void;\n\nexport interface MonophonicOptions extends InstrumentOptions {\n\tportamento: Seconds;\n\tonsilence: onSilenceCallback;\n\tdetune: Cents;\n}\n\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport abstract class Monophonic<\n\tOptions extends MonophonicOptions,\n> extends Instrument<Options> {\n\t/**\n\t * The glide time between notes.\n\t */\n\t@timeRange(0)\n\tportamento: Seconds;\n\n\t/**\n\t * Invoked when the release has finished and the output is silent.\n\t */\n\tonsilence: onSilenceCallback;\n\n\t/**\n\t * The instrument's frequency signal.\n\t */\n\tabstract readonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The instrument's detune control signal.\n\t */\n\tabstract readonly detune: Signal<\"cents\">;\n\n\tconstructor(options?: Partial<MonophonicOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tMonophonic.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.portamento = options.portamento;\n\t\tthis.onsilence = options.onsilence;\n\t}\n\n\tstatic getDefaults(): MonophonicOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tonsilence: noOp,\n\t\t\tportamento: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack of the note optionally with a given velocity.\n\t * @param  note The note to trigger.\n\t * @param  time When the note should start.\n\t * @param  velocity The velocity determines how \"loud\" the note will be.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * // trigger the note a half second from now at half velocity\n\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t */\n\ttriggerAttack(\n\t\tnote: Frequency | FrequencyClass,\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1\n\t): this {\n\t\tthis.log(\"triggerAttack\", note, time, velocity);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeAttack(seconds, velocity);\n\t\tthis.setNote(note, seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release portion of the envelope.\n\t * @param  time If no time is given, the release happens immediately.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // trigger the release a second from now\n\t * synth.triggerRelease(\"+1\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeRelease(seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal method which starts the envelope attack\n\t */\n\tprotected abstract _triggerEnvelopeAttack(\n\t\ttime: Seconds,\n\t\tvelocity: NormalRange\n\t): void;\n\n\t/**\n\t * Internal method which starts the envelope release\n\t */\n\tprotected abstract _triggerEnvelopeRelease(time: Seconds): void;\n\n\t/**\n\t * Get the level of the output at the given time. Measures\n\t * the envelope(s) value at the time.\n\t * @param time The time to query the envelope value\n\t * @return The output level between 0-1\n\t */\n\tabstract getLevelAtTime(time: Time): NormalRange;\n\n\t/**\n\t * Set the note at the given time. If no time is given, the note\n\t * will set immediately.\n\t * @param note The note to change to.\n\t * @param  time The time when the note should be set.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // change to F#6 in one quarter note from now.\n\t * synth.setNote(\"F#6\", \"+4n\");\n\t */\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedFrequency =\n\t\t\tnote instanceof FrequencyClass ? note.toFrequency() : note;\n\t\tif (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n\t\t\tconst portTime = this.toSeconds(this.portamento);\n\t\t\tthis.frequency.exponentialRampTo(\n\t\t\t\tcomputedFrequency,\n\t\t\t\tportTime,\n\t\t\t\tcomputedTime\n\t\t\t);\n\t\t} else {\n\t\t\tthis.frequency.setValueAtTime(computedFrequency, computedTime);\n\t\t}\n\t\treturn this;\n\t}\n}\n"],"mappings":";AAAA,SAASA,cAAc,QAAQ,2BAA2B;AAQ1D,SAASC,oBAAoB,QAAQ,0BAA0B;AAC/D,SAASC,IAAI,QAAQ,2BAA2B;AAChD,SAASC,UAAU,QAA2B,6BAA6B;AAE3E,SAASC,SAAS,QAAQ,2BAA2B;AAUrD;;;AAGA,OAAM,MAAgBC,UAEpB,SAAQF,UAAmB;EAuB5BG,YAAA;IACC,MAAMC,OAAO,GAAGN,oBAAoB,CACnCI,UAAU,CAACG,WAAW,EAAE,EACxBC,SAAS,CACT;IACD,KAAK,CAACF,OAAO,CAAC;IAEd,IAAI,CAACG,UAAU,GAAGH,OAAO,CAACG,UAAU;IACpC,IAAI,CAACC,SAAS,GAAGJ,OAAO,CAACI,SAAS;EACnC;EAEA,OAAOH,WAAWA,CAAA;IACjB,OAAOI,MAAM,CAACC,MAAM,CAACV,UAAU,CAACK,WAAW,EAAE,EAAE;MAC9CM,MAAM,EAAE,CAAC;MACTH,SAAS,EAAET,IAAI;MACfQ,UAAU,EAAE;KACZ,CAAC;EACH;EAEA;;;;;;;;;;EAUAK,aAAaA,CACZC,IAAgC,EAChCC,IAAW,EACXC,QAAA,GAAwB,CAAC;IAEzB,IAAI,CAACC,GAAG,CAAC,eAAe,EAAEH,IAAI,EAAEC,IAAI,EAAEC,QAAQ,CAAC;IAC/C,MAAME,OAAO,GAAG,IAAI,CAACC,SAAS,CAACJ,IAAI,CAAC;IACpC,IAAI,CAACK,sBAAsB,CAACF,OAAO,EAAEF,QAAQ,CAAC;IAC9C,IAAI,CAACK,OAAO,CAACP,IAAI,EAAEI,OAAO,CAAC;IAC3B,OAAO,IAAI;EACZ;EAEA;;;;;;;;;EASAI,cAAcA,CAACP,IAAW;IACzB,IAAI,CAACE,GAAG,CAAC,gBAAgB,EAAEF,IAAI,CAAC;IAChC,MAAMG,OAAO,GAAG,IAAI,CAACC,SAAS,CAACJ,IAAI,CAAC;IACpC,IAAI,CAACQ,uBAAuB,CAACL,OAAO,CAAC;IACrC,OAAO,IAAI;EACZ;EAuBA;;;;;;;;;;;EAWAG,OAAOA,CAACP,IAAgC,EAAEC,IAAW;IACpD,MAAMS,YAAY,GAAG,IAAI,CAACL,SAAS,CAACJ,IAAI,CAAC;IACzC,MAAMU,iBAAiB,GACtBX,IAAI,YAAYhB,cAAc,GAAGgB,IAAI,CAACY,WAAW,EAAE,GAAGZ,IAAI;IAC3D,IAAI,IAAI,CAACN,UAAU,GAAG,CAAC,IAAI,IAAI,CAACmB,cAAc,CAACH,YAAY,CAAC,GAAG,IAAI,EAAE;MACpE,MAAMI,QAAQ,GAAG,IAAI,CAACT,SAAS,CAAC,IAAI,CAACX,UAAU,CAAC;MAChD,IAAI,CAACqB,SAAS,CAACC,iBAAiB,CAC/BL,iBAAiB,EACjBG,QAAQ,EACRJ,YAAY,CACZ;IACF,CAAC,MAAM;MACN,IAAI,CAACK,SAAS,CAACE,cAAc,CAACN,iBAAiB,EAAED,YAAY,CAAC;IAC/D;IACA,OAAO,IAAI;EACZ;;AA1HAQ,UAAA,EADC9B,SAAS,CAAC,CAAC,CAAC,C,6CACO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}