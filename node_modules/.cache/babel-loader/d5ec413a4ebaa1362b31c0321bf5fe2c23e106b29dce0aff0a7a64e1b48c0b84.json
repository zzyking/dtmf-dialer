{"ast":null,"code":"import { TicksClass } from \"../core/type/Ticks.js\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { isArray, isString } from \"../core/util/TypeCheck.js\";\nimport { Part } from \"./Part.js\";\nimport { ToneEvent } from \"./ToneEvent.js\";\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal Cycles](http://tidalcycles.org/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Sequence extends ToneEvent {\n  constructor() {\n    const options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n    super(options);\n    this.name = \"Sequence\";\n    /**\n     * The object responsible for scheduling all of the events\n     */\n    this._part = new Part({\n      callback: this._seqCallback.bind(this),\n      context: this.context\n    });\n    /**\n     * private reference to all of the sequence proxies\n     */\n    this._events = [];\n    /**\n     * The proxied array\n     */\n    this._eventsArray = [];\n    this._subdivision = this.toTicks(options.subdivision);\n    this.events = options.events;\n    // set all of the values\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this.playbackRate = options.playbackRate;\n    this.probability = options.probability;\n    this.humanize = options.humanize;\n    this.mute = options.mute;\n    this.playbackRate = options.playbackRate;\n  }\n  static getDefaults() {\n    return Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n      events: [],\n      loop: true,\n      loopEnd: 0,\n      loopStart: 0,\n      subdivision: \"8n\"\n    });\n  }\n  /**\n   * The internal callback for when an event is invoked\n   */\n  _seqCallback(time, value) {\n    if (value !== null && !this.mute) {\n      this.callback(time, value);\n    }\n  }\n  /**\n   * The sequence\n   */\n  get events() {\n    return this._events;\n  }\n  set events(s) {\n    this.clear();\n    this._eventsArray = s;\n    this._events = this._createSequence(this._eventsArray);\n    this._eventsUpdated();\n  }\n  /**\n   * Start the part at the given time.\n   * @param  time    When to start the part.\n   * @param  offset  The offset index to start at\n   */\n  start(time, offset) {\n    this._part.start(time, offset ? this._indexTime(offset) : offset);\n    return this;\n  }\n  /**\n   * Stop the part at the given time.\n   * @param  time  When to stop the part.\n   */\n  stop(time) {\n    this._part.stop(time);\n    return this;\n  }\n  /**\n   * The subdivision of the sequence. This can only be\n   * set in the constructor. The subdivision is the\n   * interval between successive steps.\n   */\n  get subdivision() {\n    return new TicksClass(this.context, this._subdivision).toSeconds();\n  }\n  /**\n   * Create a sequence proxy which can be monitored to create subsequences\n   */\n  _createSequence(array) {\n    return new Proxy(array, {\n      get: (target, property) => {\n        // property is index in this case\n        return target[property];\n      },\n      set: (target, property, value) => {\n        if (isString(property) && isFinite(parseInt(property, 10))) {\n          if (isArray(value)) {\n            target[property] = this._createSequence(value);\n          } else {\n            target[property] = value;\n          }\n        } else {\n          target[property] = value;\n        }\n        this._eventsUpdated();\n        // return true to accept the changes\n        return true;\n      }\n    });\n  }\n  /**\n   * When the sequence has changed, all of the events need to be recreated\n   */\n  _eventsUpdated() {\n    this._part.clear();\n    this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n    // update the loopEnd\n    this.loopEnd = this.loopEnd;\n  }\n  /**\n   * reschedule all of the events that need to be rescheduled\n   */\n  _rescheduleSequence(sequence, subdivision, startOffset) {\n    sequence.forEach((value, index) => {\n      const eventOffset = index * subdivision + startOffset;\n      if (isArray(value)) {\n        this._rescheduleSequence(value, subdivision / value.length, eventOffset);\n      } else {\n        const startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n        this._part.add(startTime, value);\n      }\n    });\n  }\n  /**\n   * Get the time of the index given the Sequence's subdivision\n   * @param  index\n   * @return The time of that index\n   */\n  _indexTime(index) {\n    return new TicksClass(this.context, index * this._subdivision + this.startOffset).toSeconds();\n  }\n  /**\n   * Clear all of the events\n   */\n  clear() {\n    this._part.clear();\n    return this;\n  }\n  dispose() {\n    super.dispose();\n    this._part.dispose();\n    return this;\n  }\n  //-------------------------------------\n  // PROXY CALLS\n  //-------------------------------------\n  get loop() {\n    return this._part.loop;\n  }\n  set loop(l) {\n    this._part.loop = l;\n  }\n  /**\n   * The index at which the sequence should start looping\n   */\n  get loopStart() {\n    return this._loopStart;\n  }\n  set loopStart(index) {\n    this._loopStart = index;\n    this._part.loopStart = this._indexTime(index);\n  }\n  /**\n   * The index at which the sequence should end looping\n   */\n  get loopEnd() {\n    return this._loopEnd;\n  }\n  set loopEnd(index) {\n    this._loopEnd = index;\n    if (index === 0) {\n      this._part.loopEnd = this._indexTime(this._eventsArray.length);\n    } else {\n      this._part.loopEnd = this._indexTime(index);\n    }\n  }\n  get startOffset() {\n    return this._part.startOffset;\n  }\n  set startOffset(start) {\n    this._part.startOffset = start;\n  }\n  get playbackRate() {\n    return this._part.playbackRate;\n  }\n  set playbackRate(rate) {\n    this._part.playbackRate = rate;\n  }\n  get probability() {\n    return this._part.probability;\n  }\n  set probability(prob) {\n    this._part.probability = prob;\n  }\n  get progress() {\n    return this._part.progress;\n  }\n  get humanize() {\n    return this._part.humanize;\n  }\n  set humanize(variation) {\n    this._part.humanize = variation;\n  }\n  /**\n   * The number of scheduled events\n   */\n  get length() {\n    return this._part.length;\n  }\n}","map":{"version":3,"names":["TicksClass","omitFromObject","optionsFromArguments","isArray","isString","Part","ToneEvent","Sequence","constructor","options","getDefaults","arguments","name","_part","callback","_seqCallback","bind","context","_events","_eventsArray","_subdivision","toTicks","subdivision","events","loop","loopStart","loopEnd","playbackRate","probability","humanize","mute","Object","assign","time","value","s","clear","_createSequence","_eventsUpdated","start","offset","_indexTime","stop","toSeconds","array","Proxy","get","target","property","set","isFinite","parseInt","_rescheduleSequence","startOffset","sequence","forEach","index","eventOffset","length","startTime","add","dispose","l","_loopStart","_loopEnd","rate","prob","progress","variation"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/event/Sequence.ts"],"sourcesContent":["import { TicksClass } from \"../core/type/Ticks.js\";\nimport {\n\tNormalRange,\n\tPositive,\n\tSeconds,\n\tTicks,\n\tTime,\n\tTransportTime,\n} from \"../core/type/Units.js\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { isArray, isString } from \"../core/util/TypeCheck.js\";\nimport { Part } from \"./Part.js\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent.js\";\n\ntype SequenceEventDescription<T> = Array<T | SequenceEventDescription<T>>;\n\ninterface SequenceOptions<T> extends Omit<ToneEventOptions<T>, \"value\"> {\n\tloopStart: number;\n\tloopEnd: number;\n\tsubdivision: Time;\n\tevents: SequenceEventDescription<T>;\n}\n\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal Cycles](http://tidalcycles.org/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Sequence<ValueType = any> extends ToneEvent<ValueType> {\n\treadonly name: string = \"Sequence\";\n\n\t/**\n\t * The subdivison of each note\n\t */\n\tprivate _subdivision: Ticks;\n\n\t/**\n\t * The object responsible for scheduling all of the events\n\t */\n\tprivate _part: Part = new Part({\n\t\tcallback: this._seqCallback.bind(this),\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * private reference to all of the sequence proxies\n\t */\n\tprivate _events: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * The proxied array\n\t */\n\tprivate _eventsArray: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * @param  callback  The callback to invoke with every note\n\t * @param  events  The sequence of events\n\t * @param  subdivision  The subdivision between which events are placed.\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tevents?: SequenceEventDescription<ValueType>,\n\t\tsubdivision?: Time\n\t);\n\tconstructor(options?: Partial<SequenceOptions<ValueType>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tSequence.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"callback\", \"events\", \"subdivision\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._subdivision = this.toTicks(options.subdivision);\n\n\t\tthis.events = options.events;\n\n\t\t// set all of the values\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.probability = options.probability;\n\t\tthis.humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): SequenceOptions<any> {\n\t\treturn Object.assign(\n\t\t\tomitFromObject(ToneEvent.getDefaults(), [\"value\"]),\n\t\t\t{\n\t\t\t\tevents: [],\n\t\t\t\tloop: true,\n\t\t\t\tloopEnd: 0,\n\t\t\t\tloopStart: 0,\n\t\t\t\tsubdivision: \"8n\",\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * The internal callback for when an event is invoked\n\t */\n\tprivate _seqCallback(time: Seconds, value: any): void {\n\t\tif (value !== null && !this.mute) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * The sequence\n\t */\n\tget events(): any[] {\n\t\treturn this._events;\n\t}\n\tset events(s) {\n\t\tthis.clear();\n\t\tthis._eventsArray = s;\n\t\tthis._events = this._createSequence(this._eventsArray);\n\t\tthis._eventsUpdated();\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset index to start at\n\t */\n\tstart(time?: TransportTime, offset?: number): this {\n\t\tthis._part.start(time, offset ? this._indexTime(offset) : offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._part.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The subdivision of the sequence. This can only be\n\t * set in the constructor. The subdivision is the\n\t * interval between successive steps.\n\t */\n\tget subdivision(): Seconds {\n\t\treturn new TicksClass(this.context, this._subdivision).toSeconds();\n\t}\n\n\t/**\n\t * Create a sequence proxy which can be monitored to create subsequences\n\t */\n\tprivate _createSequence(array: any[]): any[] {\n\t\treturn new Proxy(array, {\n\t\t\tget: (target: any[], property: PropertyKey): any => {\n\t\t\t\t// property is index in this case\n\t\t\t\treturn target[property];\n\t\t\t},\n\t\t\tset: (\n\t\t\t\ttarget: any[],\n\t\t\t\tproperty: PropertyKey,\n\t\t\t\tvalue: any\n\t\t\t): boolean => {\n\t\t\t\tif (isString(property) && isFinite(parseInt(property, 10))) {\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\ttarget[property] = this._createSequence(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t}\n\t\t\t\tthis._eventsUpdated();\n\t\t\t\t// return true to accept the changes\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * When the sequence has changed, all of the events need to be recreated\n\t */\n\tprivate _eventsUpdated(): void {\n\t\tthis._part.clear();\n\t\tthis._rescheduleSequence(\n\t\t\tthis._eventsArray,\n\t\t\tthis._subdivision,\n\t\t\tthis.startOffset\n\t\t);\n\t\t// update the loopEnd\n\t\tthis.loopEnd = this.loopEnd;\n\t}\n\n\t/**\n\t * reschedule all of the events that need to be rescheduled\n\t */\n\tprivate _rescheduleSequence(\n\t\tsequence: any[],\n\t\tsubdivision: Ticks,\n\t\tstartOffset: Ticks\n\t): void {\n\t\tsequence.forEach((value, index) => {\n\t\t\tconst eventOffset = index * subdivision + startOffset;\n\t\t\tif (isArray(value)) {\n\t\t\t\tthis._rescheduleSequence(\n\t\t\t\t\tvalue,\n\t\t\t\t\tsubdivision / value.length,\n\t\t\t\t\teventOffset\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst startTime = new TicksClass(\n\t\t\t\t\tthis.context,\n\t\t\t\t\teventOffset,\n\t\t\t\t\t\"i\"\n\t\t\t\t).toSeconds();\n\t\t\t\tthis._part.add(startTime, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the time of the index given the Sequence's subdivision\n\t * @param  index\n\t * @return The time of that index\n\t */\n\tprivate _indexTime(index: number): Seconds {\n\t\treturn new TicksClass(\n\t\t\tthis.context,\n\t\t\tindex * this._subdivision + this.startOffset\n\t\t).toSeconds();\n\t}\n\n\t/**\n\t * Clear all of the events\n\t */\n\tclear(): this {\n\t\tthis._part.clear();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._part.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// PROXY CALLS\n\t//-------------------------------------\n\n\tget loop(): boolean | number {\n\t\treturn this._part.loop;\n\t}\n\tset loop(l) {\n\t\tthis._part.loop = l;\n\t}\n\n\t/**\n\t * The index at which the sequence should start looping\n\t */\n\tget loopStart(): number {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(index) {\n\t\tthis._loopStart = index;\n\t\tthis._part.loopStart = this._indexTime(index);\n\t}\n\n\t/**\n\t * The index at which the sequence should end looping\n\t */\n\tget loopEnd(): number {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(index) {\n\t\tthis._loopEnd = index;\n\t\tif (index === 0) {\n\t\t\tthis._part.loopEnd = this._indexTime(this._eventsArray.length);\n\t\t} else {\n\t\t\tthis._part.loopEnd = this._indexTime(index);\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._part.startOffset;\n\t}\n\tset startOffset(start) {\n\t\tthis._part.startOffset = start;\n\t}\n\n\tget playbackRate(): Positive {\n\t\treturn this._part.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._part.playbackRate = rate;\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._part.probability;\n\t}\n\tset probability(prob) {\n\t\tthis._part.probability = prob;\n\t}\n\n\tget progress(): NormalRange {\n\t\treturn this._part.progress;\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._part.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._part.humanize = variation;\n\t}\n\n\t/**\n\t * The number of scheduled events\n\t */\n\tget length(): number {\n\t\treturn this._part.length;\n\t}\n}\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,uBAAuB;AASlD,SAASC,cAAc,EAAEC,oBAAoB,QAAQ,0BAA0B;AAC/E,SAASC,OAAO,EAAEC,QAAQ,QAAQ,2BAA2B;AAC7D,SAASC,IAAI,QAAQ,WAAW;AAChC,SAASC,SAAS,QAA6C,gBAAgB;AAW/E;;;;;;;;;;;;;;;;AAgBA,OAAM,MAAOC,QAA0B,SAAQD,SAAoB;EAqClEE,YAAA;IACC,MAAMC,OAAO,GAAGP,oBAAoB,CACnCK,QAAQ,CAACG,WAAW,EAAE,EACtBC,SAAS,EACT,CAAC,UAAU,EAAE,QAAQ,EAAE,aAAa,CAAC,CACrC;IACD,KAAK,CAACF,OAAO,CAAC;IA1CN,KAAAG,IAAI,GAAW,UAAU;IAOlC;;;IAGQ,KAAAC,KAAK,GAAS,IAAIR,IAAI,CAAC;MAC9BS,QAAQ,EAAE,IAAI,CAACC,YAAY,CAACC,IAAI,CAAC,IAAI,CAAC;MACtCC,OAAO,EAAE,IAAI,CAACA;KACd,CAAC;IAEF;;;IAGQ,KAAAC,OAAO,GAAwC,EAAE;IAEzD;;;IAGQ,KAAAC,YAAY,GAAwC,EAAE;IAqB7D,IAAI,CAACC,YAAY,GAAG,IAAI,CAACC,OAAO,CAACZ,OAAO,CAACa,WAAW,CAAC;IAErD,IAAI,CAACC,MAAM,GAAGd,OAAO,CAACc,MAAM;IAE5B;IACA,IAAI,CAACC,IAAI,GAAGf,OAAO,CAACe,IAAI;IACxB,IAAI,CAACC,SAAS,GAAGhB,OAAO,CAACgB,SAAS;IAClC,IAAI,CAACC,OAAO,GAAGjB,OAAO,CAACiB,OAAO;IAC9B,IAAI,CAACC,YAAY,GAAGlB,OAAO,CAACkB,YAAY;IACxC,IAAI,CAACC,WAAW,GAAGnB,OAAO,CAACmB,WAAW;IACtC,IAAI,CAACC,QAAQ,GAAGpB,OAAO,CAACoB,QAAQ;IAChC,IAAI,CAACC,IAAI,GAAGrB,OAAO,CAACqB,IAAI;IACxB,IAAI,CAACH,YAAY,GAAGlB,OAAO,CAACkB,YAAY;EACzC;EAEA,OAAOjB,WAAWA,CAAA;IACjB,OAAOqB,MAAM,CAACC,MAAM,CACnB/B,cAAc,CAACK,SAAS,CAACI,WAAW,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,EAClD;MACCa,MAAM,EAAE,EAAE;MACVC,IAAI,EAAE,IAAI;MACVE,OAAO,EAAE,CAAC;MACVD,SAAS,EAAE,CAAC;MACZH,WAAW,EAAE;KACb,CACD;EACF;EAEA;;;EAGQP,YAAYA,CAACkB,IAAa,EAAEC,KAAU;IAC7C,IAAIA,KAAK,KAAK,IAAI,IAAI,CAAC,IAAI,CAACJ,IAAI,EAAE;MACjC,IAAI,CAAChB,QAAQ,CAACmB,IAAI,EAAEC,KAAK,CAAC;IAC3B;EACD;EAEA;;;EAGA,IAAIX,MAAMA,CAAA;IACT,OAAO,IAAI,CAACL,OAAO;EACpB;EACA,IAAIK,MAAMA,CAACY,CAAC;IACX,IAAI,CAACC,KAAK,EAAE;IACZ,IAAI,CAACjB,YAAY,GAAGgB,CAAC;IACrB,IAAI,CAACjB,OAAO,GAAG,IAAI,CAACmB,eAAe,CAAC,IAAI,CAAClB,YAAY,CAAC;IACtD,IAAI,CAACmB,cAAc,EAAE;EACtB;EAEA;;;;;EAKAC,KAAKA,CAACN,IAAoB,EAAEO,MAAe;IAC1C,IAAI,CAAC3B,KAAK,CAAC0B,KAAK,CAACN,IAAI,EAAEO,MAAM,GAAG,IAAI,CAACC,UAAU,CAACD,MAAM,CAAC,GAAGA,MAAM,CAAC;IACjE,OAAO,IAAI;EACZ;EAEA;;;;EAIAE,IAAIA,CAACT,IAAoB;IACxB,IAAI,CAACpB,KAAK,CAAC6B,IAAI,CAACT,IAAI,CAAC;IACrB,OAAO,IAAI;EACZ;EAEA;;;;;EAKA,IAAIX,WAAWA,CAAA;IACd,OAAO,IAAItB,UAAU,CAAC,IAAI,CAACiB,OAAO,EAAE,IAAI,CAACG,YAAY,CAAC,CAACuB,SAAS,EAAE;EACnE;EAEA;;;EAGQN,eAAeA,CAACO,KAAY;IACnC,OAAO,IAAIC,KAAK,CAACD,KAAK,EAAE;MACvBE,GAAG,EAAEA,CAACC,MAAa,EAAEC,QAAqB,KAAS;QAClD;QACA,OAAOD,MAAM,CAACC,QAAQ,CAAC;MACxB,CAAC;MACDC,GAAG,EAAEA,CACJF,MAAa,EACbC,QAAqB,EACrBd,KAAU,KACE;QACZ,IAAI9B,QAAQ,CAAC4C,QAAQ,CAAC,IAAIE,QAAQ,CAACC,QAAQ,CAACH,QAAQ,EAAE,EAAE,CAAC,CAAC,EAAE;UAC3D,IAAI7C,OAAO,CAAC+B,KAAK,CAAC,EAAE;YACnBa,MAAM,CAACC,QAAQ,CAAC,GAAG,IAAI,CAACX,eAAe,CAACH,KAAK,CAAC;UAC/C,CAAC,MAAM;YACNa,MAAM,CAACC,QAAQ,CAAC,GAAGd,KAAK;UACzB;QACD,CAAC,MAAM;UACNa,MAAM,CAACC,QAAQ,CAAC,GAAGd,KAAK;QACzB;QACA,IAAI,CAACI,cAAc,EAAE;QACrB;QACA,OAAO,IAAI;MACZ;KACA,CAAC;EACH;EAEA;;;EAGQA,cAAcA,CAAA;IACrB,IAAI,CAACzB,KAAK,CAACuB,KAAK,EAAE;IAClB,IAAI,CAACgB,mBAAmB,CACvB,IAAI,CAACjC,YAAY,EACjB,IAAI,CAACC,YAAY,EACjB,IAAI,CAACiC,WAAW,CAChB;IACD;IACA,IAAI,CAAC3B,OAAO,GAAG,IAAI,CAACA,OAAO;EAC5B;EAEA;;;EAGQ0B,mBAAmBA,CAC1BE,QAAe,EACfhC,WAAkB,EAClB+B,WAAkB;IAElBC,QAAQ,CAACC,OAAO,CAAC,CAACrB,KAAK,EAAEsB,KAAK,KAAI;MACjC,MAAMC,WAAW,GAAGD,KAAK,GAAGlC,WAAW,GAAG+B,WAAW;MACrD,IAAIlD,OAAO,CAAC+B,KAAK,CAAC,EAAE;QACnB,IAAI,CAACkB,mBAAmB,CACvBlB,KAAK,EACLZ,WAAW,GAAGY,KAAK,CAACwB,MAAM,EAC1BD,WAAW,CACX;MACF,CAAC,MAAM;QACN,MAAME,SAAS,GAAG,IAAI3D,UAAU,CAC/B,IAAI,CAACiB,OAAO,EACZwC,WAAW,EACX,GAAG,CACH,CAACd,SAAS,EAAE;QACb,IAAI,CAAC9B,KAAK,CAAC+C,GAAG,CAACD,SAAS,EAAEzB,KAAK,CAAC;MACjC;IACD,CAAC,CAAC;EACH;EAEA;;;;;EAKQO,UAAUA,CAACe,KAAa;IAC/B,OAAO,IAAIxD,UAAU,CACpB,IAAI,CAACiB,OAAO,EACZuC,KAAK,GAAG,IAAI,CAACpC,YAAY,GAAG,IAAI,CAACiC,WAAW,CAC5C,CAACV,SAAS,EAAE;EACd;EAEA;;;EAGAP,KAAKA,CAAA;IACJ,IAAI,CAACvB,KAAK,CAACuB,KAAK,EAAE;IAClB,OAAO,IAAI;EACZ;EAEAyB,OAAOA,CAAA;IACN,KAAK,CAACA,OAAO,EAAE;IACf,IAAI,CAAChD,KAAK,CAACgD,OAAO,EAAE;IACpB,OAAO,IAAI;EACZ;EAEA;EACA;EACA;EAEA,IAAIrC,IAAIA,CAAA;IACP,OAAO,IAAI,CAACX,KAAK,CAACW,IAAI;EACvB;EACA,IAAIA,IAAIA,CAACsC,CAAC;IACT,IAAI,CAACjD,KAAK,CAACW,IAAI,GAAGsC,CAAC;EACpB;EAEA;;;EAGA,IAAIrC,SAASA,CAAA;IACZ,OAAO,IAAI,CAACsC,UAAU;EACvB;EACA,IAAItC,SAASA,CAAC+B,KAAK;IAClB,IAAI,CAACO,UAAU,GAAGP,KAAK;IACvB,IAAI,CAAC3C,KAAK,CAACY,SAAS,GAAG,IAAI,CAACgB,UAAU,CAACe,KAAK,CAAC;EAC9C;EAEA;;;EAGA,IAAI9B,OAAOA,CAAA;IACV,OAAO,IAAI,CAACsC,QAAQ;EACrB;EACA,IAAItC,OAAOA,CAAC8B,KAAK;IAChB,IAAI,CAACQ,QAAQ,GAAGR,KAAK;IACrB,IAAIA,KAAK,KAAK,CAAC,EAAE;MAChB,IAAI,CAAC3C,KAAK,CAACa,OAAO,GAAG,IAAI,CAACe,UAAU,CAAC,IAAI,CAACtB,YAAY,CAACuC,MAAM,CAAC;IAC/D,CAAC,MAAM;MACN,IAAI,CAAC7C,KAAK,CAACa,OAAO,GAAG,IAAI,CAACe,UAAU,CAACe,KAAK,CAAC;IAC5C;EACD;EAEA,IAAIH,WAAWA,CAAA;IACd,OAAO,IAAI,CAACxC,KAAK,CAACwC,WAAW;EAC9B;EACA,IAAIA,WAAWA,CAACd,KAAK;IACpB,IAAI,CAAC1B,KAAK,CAACwC,WAAW,GAAGd,KAAK;EAC/B;EAEA,IAAIZ,YAAYA,CAAA;IACf,OAAO,IAAI,CAACd,KAAK,CAACc,YAAY;EAC/B;EACA,IAAIA,YAAYA,CAACsC,IAAI;IACpB,IAAI,CAACpD,KAAK,CAACc,YAAY,GAAGsC,IAAI;EAC/B;EAEA,IAAIrC,WAAWA,CAAA;IACd,OAAO,IAAI,CAACf,KAAK,CAACe,WAAW;EAC9B;EACA,IAAIA,WAAWA,CAACsC,IAAI;IACnB,IAAI,CAACrD,KAAK,CAACe,WAAW,GAAGsC,IAAI;EAC9B;EAEA,IAAIC,QAAQA,CAAA;IACX,OAAO,IAAI,CAACtD,KAAK,CAACsD,QAAQ;EAC3B;EAEA,IAAItC,QAAQA,CAAA;IACX,OAAO,IAAI,CAAChB,KAAK,CAACgB,QAAQ;EAC3B;EACA,IAAIA,QAAQA,CAACuC,SAAS;IACrB,IAAI,CAACvD,KAAK,CAACgB,QAAQ,GAAGuC,SAAS;EAChC;EAEA;;;EAGA,IAAIV,MAAMA,CAAA;IACT,OAAO,IAAI,CAAC7C,KAAK,CAAC6C,MAAM;EACzB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}