{"ast":null,"code":"/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n  constructor(callback, type, updateInterval, contextSampleRate) {\n    this._callback = callback;\n    this._type = type;\n    this._minimumUpdateInterval = Math.max(128 / (contextSampleRate || 44100), 0.001);\n    this.updateInterval = updateInterval;\n    // create the clock source for the first time\n    this._createClock();\n  }\n  /**\n   * Generate a web worker\n   */\n  _createWorker() {\n    const blob = new Blob([/* javascript */`\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`], {\n      type: \"text/javascript\"\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    const worker = new Worker(blobUrl);\n    worker.onmessage = this._callback.bind(this);\n    this._worker = worker;\n  }\n  /**\n   * Create a timeout loop\n   */\n  _createTimeout() {\n    this._timeout = setTimeout(() => {\n      this._createTimeout();\n      this._callback();\n    }, this._updateInterval * 1000);\n  }\n  /**\n   * Create the clock source.\n   */\n  _createClock() {\n    if (this._type === \"worker\") {\n      try {\n        this._createWorker();\n      } catch (e) {\n        // workers not supported, fallback to timeout\n        this._type = \"timeout\";\n        this._createClock();\n      }\n    } else if (this._type === \"timeout\") {\n      this._createTimeout();\n    }\n  }\n  /**\n   * Clean up the current clock source\n   */\n  _disposeClock() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n    if (this._worker) {\n      this._worker.terminate();\n      this._worker.onmessage = null;\n    }\n  }\n  /**\n   * The rate in seconds the ticker will update\n   */\n  get updateInterval() {\n    return this._updateInterval;\n  }\n  set updateInterval(interval) {\n    var _a;\n    this._updateInterval = Math.max(interval, this._minimumUpdateInterval);\n    if (this._type === \"worker\") {\n      (_a = this._worker) === null || _a === void 0 ? void 0 : _a.postMessage(this._updateInterval * 1000);\n    }\n  }\n  /**\n   * The type of the ticker, either a worker or a timeout\n   */\n  get type() {\n    return this._type;\n  }\n  set type(type) {\n    this._disposeClock();\n    this._type = type;\n    this._createClock();\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    this._disposeClock();\n  }\n}","map":{"version":3,"names":["Ticker","constructor","callback","type","updateInterval","contextSampleRate","_callback","_type","_minimumUpdateInterval","Math","max","_createClock","_createWorker","blob","Blob","_updateInterval","toFixed","blobUrl","URL","createObjectURL","worker","Worker","onmessage","bind","_worker","_createTimeout","_timeout","setTimeout","e","_disposeClock","clearTimeout","terminate","interval","_a","postMessage","dispose"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/core/clock/Ticker.ts"],"sourcesContent":["import { Seconds } from \"../type/Units.js\";\n\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval!: Seconds;\n\n\t/**\n\t * The lowest allowable interval, preferably calculated from context sampleRate\n\t */\n\tprivate _minimumUpdateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: ReturnType<typeof setTimeout>;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(\n\t\tcallback: () => void,\n\t\ttype: TickerClockSource,\n\t\tupdateInterval: Seconds,\n\t\tcontextSampleRate?: number\n\t) {\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._minimumUpdateInterval = Math.max(\n\t\t\t128 / (contextSampleRate || 44100),\n\t\t\t0.001\n\t\t);\n\t\tthis.updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\t\tconst blob = new Blob(\n\t\t\t[\n\t\t\t\t/* javascript */ `\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`,\n\t\t\t],\n\t\t\t{ type: \"text/javascript\" }\n\t\t);\n\t\tconst blobUrl = URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = setTimeout(() => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, this._minimumUpdateInterval);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker?.postMessage(this._updateInterval * 1000);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n"],"mappings":"AAIA;;;;AAIA,OAAM,MAAOA,MAAM;EA+BlBC,YACCC,QAAoB,EACpBC,IAAuB,EACvBC,cAAuB,EACvBC,iBAA0B;IAE1B,IAAI,CAACC,SAAS,GAAGJ,QAAQ;IACzB,IAAI,CAACK,KAAK,GAAGJ,IAAI;IACjB,IAAI,CAACK,sBAAsB,GAAGC,IAAI,CAACC,GAAG,CACrC,GAAG,IAAIL,iBAAiB,IAAI,KAAK,CAAC,EAClC,KAAK,CACL;IACD,IAAI,CAACD,cAAc,GAAGA,cAAc;IAEpC;IACA,IAAI,CAACO,YAAY,EAAE;EACpB;EAEA;;;EAGQC,aAAaA,CAAA;IACpB,MAAMC,IAAI,GAAG,IAAIC,IAAI,CACpB,CACC,gBAAiB;;wBAEG,CAAC,IAAI,CAACC,eAAe,GAAG,IAAI,EAAEC,OAAO,CAAC,CAAC,CAAC;;;;;;;;;;;;;IAa5D,CACA,EACD;MAAEb,IAAI,EAAE;IAAiB,CAAE,CAC3B;IACD,MAAMc,OAAO,GAAGC,GAAG,CAACC,eAAe,CAACN,IAAI,CAAC;IACzC,MAAMO,MAAM,GAAG,IAAIC,MAAM,CAACJ,OAAO,CAAC;IAElCG,MAAM,CAACE,SAAS,GAAG,IAAI,CAAChB,SAAS,CAACiB,IAAI,CAAC,IAAI,CAAC;IAE5C,IAAI,CAACC,OAAO,GAAGJ,MAAM;EACtB;EAEA;;;EAGQK,cAAcA,CAAA;IACrB,IAAI,CAACC,QAAQ,GAAGC,UAAU,CAAC,MAAK;MAC/B,IAAI,CAACF,cAAc,EAAE;MACrB,IAAI,CAACnB,SAAS,EAAE;IACjB,CAAC,EAAE,IAAI,CAACS,eAAe,GAAG,IAAI,CAAC;EAChC;EAEA;;;EAGQJ,YAAYA,CAAA;IACnB,IAAI,IAAI,CAACJ,KAAK,KAAK,QAAQ,EAAE;MAC5B,IAAI;QACH,IAAI,CAACK,aAAa,EAAE;MACrB,CAAC,CAAC,OAAOgB,CAAC,EAAE;QACX;QACA,IAAI,CAACrB,KAAK,GAAG,SAAS;QACtB,IAAI,CAACI,YAAY,EAAE;MACpB;IACD,CAAC,MAAM,IAAI,IAAI,CAACJ,KAAK,KAAK,SAAS,EAAE;MACpC,IAAI,CAACkB,cAAc,EAAE;IACtB;EACD;EAEA;;;EAGQI,aAAaA,CAAA;IACpB,IAAI,IAAI,CAACH,QAAQ,EAAE;MAClBI,YAAY,CAAC,IAAI,CAACJ,QAAQ,CAAC;IAC5B;IACA,IAAI,IAAI,CAACF,OAAO,EAAE;MACjB,IAAI,CAACA,OAAO,CAACO,SAAS,EAAE;MACxB,IAAI,CAACP,OAAO,CAACF,SAAS,GAAG,IAAI;IAC9B;EACD;EAEA;;;EAGA,IAAIlB,cAAcA,CAAA;IACjB,OAAO,IAAI,CAACW,eAAe;EAC5B;EACA,IAAIX,cAAcA,CAAC4B,QAAiB;;IACnC,IAAI,CAACjB,eAAe,GAAGN,IAAI,CAACC,GAAG,CAACsB,QAAQ,EAAE,IAAI,CAACxB,sBAAsB,CAAC;IACtE,IAAI,IAAI,CAACD,KAAK,KAAK,QAAQ,EAAE;MAC5B,CAAA0B,EAAA,OAAI,CAACT,OAAO,cAAAS,EAAA,uBAAAA,EAAA,CAAEC,WAAW,CAAC,IAAI,CAACnB,eAAe,GAAG,IAAI,CAAC;IACvD;EACD;EAEA;;;EAGA,IAAIZ,IAAIA,CAAA;IACP,OAAO,IAAI,CAACI,KAAK;EAClB;EACA,IAAIJ,IAAIA,CAACA,IAAuB;IAC/B,IAAI,CAAC0B,aAAa,EAAE;IACpB,IAAI,CAACtB,KAAK,GAAGJ,IAAI;IACjB,IAAI,CAACQ,YAAY,EAAE;EACpB;EAEA;;;EAGAwB,OAAOA,CAAA;IACN,IAAI,CAACN,aAAa,EAAE;EACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}