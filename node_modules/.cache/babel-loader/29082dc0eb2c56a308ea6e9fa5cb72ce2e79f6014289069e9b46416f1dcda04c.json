{"ast":null,"code":"import { assert } from \"../core/util/Debug.js\";\nimport { clamp } from \"../core/util/Math.js\";\n/**\n * Start at the first value and go up to the last\n */\nfunction* upPatternGen(numValues) {\n  let index = 0;\n  while (index < numValues) {\n    index = clamp(index, 0, numValues - 1);\n    yield index;\n    index++;\n  }\n}\n/**\n * Start at the last value and go down to 0\n */\nfunction* downPatternGen(numValues) {\n  let index = numValues - 1;\n  while (index >= 0) {\n    index = clamp(index, 0, numValues - 1);\n    yield index;\n    index--;\n  }\n}\n/**\n * Infinitely yield the generator\n */\nfunction* infiniteGen(numValues, gen) {\n  while (true) {\n    yield* gen(numValues);\n  }\n}\n/**\n * Alternate between two generators\n */\nfunction* alternatingGenerator(numValues, directionUp) {\n  let index = directionUp ? 0 : numValues - 1;\n  while (true) {\n    index = clamp(index, 0, numValues - 1);\n    yield index;\n    if (directionUp) {\n      index++;\n      if (index >= numValues - 1) {\n        directionUp = false;\n      }\n    } else {\n      index--;\n      if (index <= 0) {\n        directionUp = true;\n      }\n    }\n  }\n}\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction* jumpUp(numValues) {\n  let index = 0;\n  let stepIndex = 0;\n  while (index < numValues) {\n    index = clamp(index, 0, numValues - 1);\n    yield index;\n    stepIndex++;\n    index += stepIndex % 2 ? 2 : -1;\n  }\n}\n/**\n * Starting from the top move down 2, up 1\n */\nfunction* jumpDown(numValues) {\n  let index = numValues - 1;\n  let stepIndex = 0;\n  while (index >= 0) {\n    index = clamp(index, 0, numValues - 1);\n    yield index;\n    stepIndex++;\n    index += stepIndex % 2 ? -2 : 1;\n  }\n}\n/**\n * Choose a random index each time\n */\nfunction* randomGen(numValues) {\n  while (true) {\n    const randomIndex = Math.floor(Math.random() * numValues);\n    yield randomIndex;\n  }\n}\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction* randomOnce(numValues) {\n  // create an array of indices\n  const copy = [];\n  for (let i = 0; i < numValues; i++) {\n    copy.push(i);\n  }\n  while (copy.length > 0) {\n    // random choose an index, and then remove it so it's not chosen again\n    const randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n    const index = clamp(randVal[0], 0, numValues - 1);\n    yield index;\n  }\n}\n/**\n * Randomly choose to walk up or down 1 index\n */\nfunction* randomWalk(numValues) {\n  // randomly choose a starting index\n  let index = Math.floor(Math.random() * numValues);\n  while (true) {\n    if (index === 0) {\n      index++; // at bottom, so force upward step\n    } else if (index === numValues - 1) {\n      index--; // at top, so force downward step\n    } else if (Math.random() < 0.5) {\n      // else choose random downward or upward step\n      index--;\n    } else {\n      index++;\n    }\n    yield index;\n  }\n}\n/**\n * PatternGenerator returns a generator which will yield numbers between 0 and numValues\n * according to the passed in pattern that can be used as indexes into an array of size numValues.\n * @param numValues The size of the array to emit indexes for\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function* PatternGenerator(numValues, pattern = \"up\", index = 0) {\n  // safeguards\n  assert(numValues >= 1, \"The number of values must be at least one\");\n  switch (pattern) {\n    case \"up\":\n      yield* infiniteGen(numValues, upPatternGen);\n    case \"down\":\n      yield* infiniteGen(numValues, downPatternGen);\n    case \"upDown\":\n      yield* alternatingGenerator(numValues, true);\n    case \"downUp\":\n      yield* alternatingGenerator(numValues, false);\n    case \"alternateUp\":\n      yield* infiniteGen(numValues, jumpUp);\n    case \"alternateDown\":\n      yield* infiniteGen(numValues, jumpDown);\n    case \"random\":\n      yield* randomGen(numValues);\n    case \"randomOnce\":\n      yield* infiniteGen(numValues, randomOnce);\n    case \"randomWalk\":\n      yield* randomWalk(numValues);\n  }\n}","map":{"version":3,"names":["assert","clamp","upPatternGen","numValues","index","downPatternGen","infiniteGen","gen","alternatingGenerator","directionUp","jumpUp","stepIndex","jumpDown","randomGen","randomIndex","Math","floor","random","randomOnce","copy","i","push","length","randVal","splice","randomWalk","PatternGenerator","pattern"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/event/PatternGenerator.ts"],"sourcesContent":["import { assert } from \"../core/util/Debug.js\";\nimport { clamp } from \"../core/util/Math.js\";\n\n/**\n * The name of the patterns\n */\nexport type PatternName =\n\t| \"up\"\n\t| \"down\"\n\t| \"upDown\"\n\t| \"downUp\"\n\t| \"alternateUp\"\n\t| \"alternateDown\"\n\t| \"random\"\n\t| \"randomOnce\"\n\t| \"randomWalk\";\n\n/**\n * Start at the first value and go up to the last\n */\nfunction* upPatternGen<T>(numValues: number): IterableIterator<number> {\n\tlet index = 0;\n\twhile (index < numValues) {\n\t\tindex = clamp(index, 0, numValues - 1);\n\t\tyield index;\n\t\tindex++;\n\t}\n}\n\n/**\n * Start at the last value and go down to 0\n */\nfunction* downPatternGen<T>(numValues: number): IterableIterator<number> {\n\tlet index = numValues - 1;\n\twhile (index >= 0) {\n\t\tindex = clamp(index, 0, numValues - 1);\n\t\tyield index;\n\t\tindex--;\n\t}\n}\n\n/**\n * Infinitely yield the generator\n */\nfunction* infiniteGen<T>(\n\tnumValues: number,\n\tgen: typeof upPatternGen\n): IterableIterator<number> {\n\twhile (true) {\n\t\tyield* gen(numValues);\n\t}\n}\n\n/**\n * Alternate between two generators\n */\nfunction* alternatingGenerator<T>(\n\tnumValues: number,\n\tdirectionUp: boolean\n): IterableIterator<number> {\n\tlet index = directionUp ? 0 : numValues - 1;\n\twhile (true) {\n\t\tindex = clamp(index, 0, numValues - 1);\n\t\tyield index;\n\t\tif (directionUp) {\n\t\t\tindex++;\n\t\t\tif (index >= numValues - 1) {\n\t\t\t\tdirectionUp = false;\n\t\t\t}\n\t\t} else {\n\t\t\tindex--;\n\t\t\tif (index <= 0) {\n\t\t\t\tdirectionUp = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction* jumpUp<T>(numValues: number): IterableIterator<number> {\n\tlet index = 0;\n\tlet stepIndex = 0;\n\twhile (index < numValues) {\n\t\tindex = clamp(index, 0, numValues - 1);\n\t\tyield index;\n\t\tstepIndex++;\n\t\tindex += stepIndex % 2 ? 2 : -1;\n\t}\n}\n\n/**\n * Starting from the top move down 2, up 1\n */\nfunction* jumpDown<T>(numValues: number): IterableIterator<number> {\n\tlet index = numValues - 1;\n\tlet stepIndex = 0;\n\twhile (index >= 0) {\n\t\tindex = clamp(index, 0, numValues - 1);\n\t\tyield index;\n\t\tstepIndex++;\n\t\tindex += stepIndex % 2 ? -2 : 1;\n\t}\n}\n\n/**\n * Choose a random index each time\n */\nfunction* randomGen<T>(numValues: number): IterableIterator<number> {\n\twhile (true) {\n\t\tconst randomIndex = Math.floor(Math.random() * numValues);\n\t\tyield randomIndex;\n\t}\n}\n\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction* randomOnce<T>(numValues: number): IterableIterator<number> {\n\t// create an array of indices\n\tconst copy: number[] = [];\n\tfor (let i = 0; i < numValues; i++) {\n\t\tcopy.push(i);\n\t}\n\twhile (copy.length > 0) {\n\t\t// random choose an index, and then remove it so it's not chosen again\n\t\tconst randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n\t\tconst index = clamp(randVal[0], 0, numValues - 1);\n\t\tyield index;\n\t}\n}\n\n/**\n * Randomly choose to walk up or down 1 index\n */\nfunction* randomWalk<T>(numValues: number): IterableIterator<number> {\n\t// randomly choose a starting index\n\tlet index = Math.floor(Math.random() * numValues);\n\twhile (true) {\n\t\tif (index === 0) {\n\t\t\tindex++; // at bottom, so force upward step\n\t\t} else if (index === numValues - 1) {\n\t\t\tindex--; // at top, so force downward step\n\t\t} else if (Math.random() < 0.5) {\n\t\t\t// else choose random downward or upward step\n\t\t\tindex--;\n\t\t} else {\n\t\t\tindex++;\n\t\t}\n\t\tyield index;\n\t}\n}\n\n/**\n * PatternGenerator returns a generator which will yield numbers between 0 and numValues\n * according to the passed in pattern that can be used as indexes into an array of size numValues.\n * @param numValues The size of the array to emit indexes for\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function* PatternGenerator(\n\tnumValues: number,\n\tpattern: PatternName = \"up\",\n\tindex = 0\n): Iterator<number> {\n\t// safeguards\n\tassert(numValues >= 1, \"The number of values must be at least one\");\n\tswitch (pattern) {\n\t\tcase \"up\":\n\t\t\tyield* infiniteGen(numValues, upPatternGen);\n\t\tcase \"down\":\n\t\t\tyield* infiniteGen(numValues, downPatternGen);\n\t\tcase \"upDown\":\n\t\t\tyield* alternatingGenerator(numValues, true);\n\t\tcase \"downUp\":\n\t\t\tyield* alternatingGenerator(numValues, false);\n\t\tcase \"alternateUp\":\n\t\t\tyield* infiniteGen(numValues, jumpUp);\n\t\tcase \"alternateDown\":\n\t\t\tyield* infiniteGen(numValues, jumpDown);\n\t\tcase \"random\":\n\t\t\tyield* randomGen(numValues);\n\t\tcase \"randomOnce\":\n\t\t\tyield* infiniteGen(numValues, randomOnce);\n\t\tcase \"randomWalk\":\n\t\t\tyield* randomWalk(numValues);\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}