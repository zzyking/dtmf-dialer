{"ast":null,"code":"import { connect } from \"../../core/context/ToneAudioNode.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer.js\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { noOp } from \"../../core/util/Interface.js\";\nimport { isDefined } from \"../../core/util/TypeCheck.js\";\nimport { assert } from \"../../core/util/Debug.js\";\nimport { OneShotSource } from \"../OneShotSource.js\";\nimport { EQ, GTE, LT } from \"../../core/util/Math.js\";\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource {\n  constructor() {\n    const options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n    super(options);\n    this.name = \"ToneBufferSource\";\n    /**\n     * The oscillator\n     */\n    this._source = this.context.createBufferSource();\n    this._internalChannels = [this._source];\n    /**\n     * indicators if the source has started/stopped\n     */\n    this._sourceStarted = false;\n    this._sourceStopped = false;\n    connect(this._source, this._gainNode);\n    this._source.onended = () => this._stopSource();\n    /**\n     * The playbackRate of the buffer\n     */\n    this.playbackRate = new Param({\n      context: this.context,\n      param: this._source.playbackRate,\n      units: \"positive\",\n      value: options.playbackRate\n    });\n    // set some values initially\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n    this._internalChannels.push(this._source);\n  }\n  static getDefaults() {\n    return Object.assign(OneShotSource.getDefaults(), {\n      url: new ToneAudioBuffer(),\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      onload: noOp,\n      onerror: noOp,\n      playbackRate: 1\n    });\n  }\n  /**\n   * The fadeIn time of the amplitude envelope.\n   */\n  get fadeIn() {\n    return this._fadeIn;\n  }\n  set fadeIn(t) {\n    this._fadeIn = t;\n  }\n  /**\n   * The fadeOut time of the amplitude envelope.\n   */\n  get fadeOut() {\n    return this._fadeOut;\n  }\n  set fadeOut(t) {\n    this._fadeOut = t;\n  }\n  /**\n   * The curve applied to the fades, either \"linear\" or \"exponential\"\n   */\n  get curve() {\n    return this._curve;\n  }\n  set curve(t) {\n    this._curve = t;\n  }\n  /**\n   * Start the buffer\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n   * @param  gain  The gain to play the buffer back at.\n   */\n  start(time, offset, duration, gain = 1) {\n    assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n    const computedTime = this.toSeconds(time);\n    // apply the gain envelope\n    this._startGain(computedTime, gain);\n    // if it's a loop the default offset is the loopstart point\n    if (this.loop) {\n      offset = defaultArg(offset, this.loopStart);\n    } else {\n      // otherwise the default offset is 0\n      offset = defaultArg(offset, 0);\n    }\n    // make sure the offset is not less than 0\n    let computedOffset = Math.max(this.toSeconds(offset), 0);\n    // start the buffer source\n    if (this.loop) {\n      // modify the offset if it's greater than the loop time\n      const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n      const loopStart = this.toSeconds(this.loopStart);\n      const loopDuration = loopEnd - loopStart;\n      // move the offset back\n      if (GTE(computedOffset, loopEnd)) {\n        computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;\n      }\n      // when the offset is very close to the duration, set it to 0\n      if (EQ(computedOffset, this.buffer.duration)) {\n        computedOffset = 0;\n      }\n    }\n    // this.buffer.loaded would have return false if the AudioBuffer was undefined\n    this._source.buffer = this.buffer.get();\n    this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n    if (LT(computedOffset, this.buffer.duration)) {\n      this._sourceStarted = true;\n      this._source.start(computedTime, computedOffset);\n    }\n    // if a duration is given, schedule a stop\n    if (isDefined(duration)) {\n      let computedDur = this.toSeconds(duration);\n      // make sure it's never negative\n      computedDur = Math.max(computedDur, 0);\n      this.stop(computedTime + computedDur);\n    }\n    return this;\n  }\n  _stopSource(time) {\n    if (!this._sourceStopped && this._sourceStarted) {\n      this._sourceStopped = true;\n      this._source.stop(this.toSeconds(time));\n      this._onended();\n    }\n  }\n  /**\n   * If loop is true, the loop will start at this position.\n   */\n  get loopStart() {\n    return this._source.loopStart;\n  }\n  set loopStart(loopStart) {\n    this._source.loopStart = this.toSeconds(loopStart);\n  }\n  /**\n   * If loop is true, the loop will end at this position.\n   */\n  get loopEnd() {\n    return this._source.loopEnd;\n  }\n  set loopEnd(loopEnd) {\n    this._source.loopEnd = this.toSeconds(loopEnd);\n  }\n  /**\n   * The audio buffer belonging to the player.\n   */\n  get buffer() {\n    return this._buffer;\n  }\n  set buffer(buffer) {\n    this._buffer.set(buffer);\n  }\n  /**\n   * If the buffer should loop once it's over.\n   */\n  get loop() {\n    return this._source.loop;\n  }\n  set loop(loop) {\n    this._source.loop = loop;\n    if (this._sourceStarted) {\n      this.cancelStop();\n    }\n  }\n  /**\n   * Clean up.\n   */\n  dispose() {\n    super.dispose();\n    this._source.onended = null;\n    this._source.disconnect();\n    this._buffer.dispose();\n    this.playbackRate.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["connect","Param","ToneAudioBuffer","defaultArg","optionsFromArguments","noOp","isDefined","assert","OneShotSource","EQ","GTE","LT","ToneBufferSource","constructor","options","getDefaults","arguments","name","_source","context","createBufferSource","_internalChannels","_sourceStarted","_sourceStopped","_gainNode","onended","_stopSource","playbackRate","param","units","value","loop","loopStart","loopEnd","_buffer","url","onload","onerror","push","Object","assign","fadeIn","_fadeIn","t","fadeOut","_fadeOut","curve","_curve","start","time","offset","duration","gain","buffer","loaded","computedTime","toSeconds","_startGain","computedOffset","Math","max","loopDuration","get","computedDur","stop","_onended","set","cancelStop","dispose","disconnect"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/source/buffer/ToneBufferSource.ts"],"sourcesContent":["import { connect } from \"../../core/context/ToneAudioNode.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer.js\";\nimport { GainFactor, Positive, Seconds, Time } from \"../../core/type/Units.js\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { noOp } from \"../../core/util/Interface.js\";\nimport { isDefined } from \"../../core/util/TypeCheck.js\";\nimport { assert } from \"../../core/util/Debug.js\";\nimport {\n\tOneShotSource,\n\tOneShotSourceCurve,\n\tOneShotSourceOptions,\n} from \"../OneShotSource.js\";\nimport { EQ, GTE, LT } from \"../../core/util/Math.js\";\n\nexport type ToneBufferSourceCurve = OneShotSourceCurve;\n\nexport interface ToneBufferSourceOptions extends OneShotSourceOptions {\n\turl: string | AudioBuffer | ToneAudioBuffer;\n\tcurve: ToneBufferSourceCurve;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\treadonly name: string = \"ToneBufferSource\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._source];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<\"positive\">;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted = false;\n\tprivate _sourceStopped = false;\n\n\t/**\n\t * @param url The buffer to play or url to load\n\t * @param onload The callback to invoke when the buffer is done playing.\n\t */\n\tconstructor(\n\t\turl?: ToneAudioBuffer | AudioBuffer | string,\n\t\tonload?: () => void\n\t);\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tToneBufferSource.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"url\", \"onload\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = () => this._stopSource();\n\n\t\t/**\n\t\t * The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._source.playbackRate,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(\n\t\t\toptions.url,\n\t\t\toptions.onload,\n\t\t\toptions.onerror\n\t\t);\n\n\t\tthis._internalChannels.push(this._source);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\turl: new ToneAudioBuffer(),\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\tplaybackRate: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): ToneBufferSourceCurve {\n\t\treturn this._curve;\n\t}\n\tset curve(t) {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t * Start the buffer\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t * @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(\n\t\ttime?: Time,\n\t\toffset?: Time,\n\t\tduration?: Time,\n\t\tgain: GainFactor = 1\n\t): this {\n\t\tassert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\tconst computedTime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(computedTime, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\t// make sure the offset is not less than 0\n\t\tlet computedOffset = Math.max(this.toSeconds(offset), 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd =\n\t\t\t\tthis.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (GTE(computedOffset, loopEnd)) {\n\t\t\t\tcomputedOffset =\n\t\t\t\t\t((computedOffset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t\t// when the offset is very close to the duration, set it to 0\n\t\t\tif (EQ(computedOffset, this.buffer.duration)) {\n\t\t\t\tcomputedOffset = 0;\n\t\t\t}\n\t\t}\n\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd =\n\t\t\tthis.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (LT(computedOffset, this.buffer.duration)) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(computedTime, computedOffset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(computedTime + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tif (!this._sourceStopped && this._sourceStarted) {\n\t\t\tthis._sourceStopped = true;\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._onended();\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}