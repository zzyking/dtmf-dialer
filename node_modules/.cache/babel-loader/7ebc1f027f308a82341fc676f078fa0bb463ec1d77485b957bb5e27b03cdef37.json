{"ast":null,"code":"import { Gain } from \"../../core/context/Gain.js\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode.js\";\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90째.\n * Here the `offset90` phase is offset by +90째 in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\nexport class PhaseShiftAllpass extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    this.name = \"PhaseShiftAllpass\";\n    this.input = new Gain({\n      context: this.context\n    });\n    /**\n     * The phase shifted output\n     */\n    this.output = new Gain({\n      context: this.context\n    });\n    /**\n     * The PhaseShifted allpass output\n     */\n    this.offset90 = new Gain({\n      context: this.context\n    });\n    const allpassBank1Values = [0.6923878, 0.9360654322959, 0.988229522686, 0.9987488452737];\n    const allpassBank2Values = [0.4021921162426, 0.856171088242, 0.9722909545651, 0.9952884791278];\n    this._bank0 = this._createAllPassFilterBank(allpassBank1Values);\n    this._bank1 = this._createAllPassFilterBank(allpassBank2Values);\n    this._oneSampleDelay = this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]);\n    // connect Allpass filter banks\n    connectSeries(this.input, ...this._bank0, this._oneSampleDelay, this.output);\n    connectSeries(this.input, ...this._bank1, this.offset90);\n  }\n  /**\n   * Create all of the IIR filters from an array of values using the coefficient calculation.\n   */\n  _createAllPassFilterBank(bankValues) {\n    const nodes = bankValues.map(value => {\n      const coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n      return this.context.createIIRFilter(coefficients[0], coefficients[1]);\n    });\n    return nodes;\n  }\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n    this.output.dispose();\n    this.offset90.dispose();\n    this._bank0.forEach(f => f.disconnect());\n    this._bank1.forEach(f => f.disconnect());\n    this._oneSampleDelay.disconnect();\n    return this;\n  }\n}","map":{"version":3,"names":["Gain","connectSeries","ToneAudioNode","PhaseShiftAllpass","constructor","options","name","input","context","output","offset90","allpassBank1Values","allpassBank2Values","_bank0","_createAllPassFilterBank","_bank1","_oneSampleDelay","createIIRFilter","bankValues","nodes","map","value","coefficients","dispose","forEach","f","disconnect"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/component/filter/PhaseShiftAllpass.ts"],"sourcesContent":["import { Gain } from \"../../core/context/Gain.js\";\nimport {\n\tconnectSeries,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\n\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90째.\n * Here the `offset90` phase is offset by +90째 in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\nexport class PhaseShiftAllpass extends ToneAudioNode<ToneAudioNodeOptions> {\n\treadonly name: string = \"PhaseShiftAllpass\";\n\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * The Allpass filter in the first bank\n\t */\n\tprivate _bank0: IIRFilterNode[];\n\n\t/**\n\t * The Allpass filter in the seconds bank\n\t */\n\tprivate _bank1: IIRFilterNode[];\n\n\t/**\n\t * A IIR filter implementing a delay by one sample used by the first bank\n\t */\n\tprivate _oneSampleDelay: IIRFilterNode;\n\n\t/**\n\t * The phase shifted output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * The PhaseShifted allpass output\n\t */\n\treadonly offset90 = new Gain({ context: this.context });\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>) {\n\t\tsuper(options);\n\n\t\tconst allpassBank1Values = [\n\t\t\t0.6923878, 0.9360654322959, 0.988229522686, 0.9987488452737,\n\t\t];\n\t\tconst allpassBank2Values = [\n\t\t\t0.4021921162426, 0.856171088242, 0.9722909545651, 0.9952884791278,\n\t\t];\n\n\t\tthis._bank0 = this._createAllPassFilterBank(allpassBank1Values);\n\t\tthis._bank1 = this._createAllPassFilterBank(allpassBank2Values);\n\t\tthis._oneSampleDelay = this.context.createIIRFilter(\n\t\t\t[0.0, 1.0],\n\t\t\t[1.0, 0.0]\n\t\t);\n\n\t\t// connect Allpass filter banks\n\t\tconnectSeries(\n\t\t\tthis.input,\n\t\t\t...this._bank0,\n\t\t\tthis._oneSampleDelay,\n\t\t\tthis.output\n\t\t);\n\t\tconnectSeries(this.input, ...this._bank1, this.offset90);\n\t}\n\n\t/**\n\t * Create all of the IIR filters from an array of values using the coefficient calculation.\n\t */\n\tprivate _createAllPassFilterBank(bankValues: number[]): IIRFilterNode[] {\n\t\tconst nodes: IIRFilterNode[] = bankValues.map((value) => {\n\t\t\tconst coefficients = [\n\t\t\t\t[value * value, 0, -1],\n\t\t\t\t[1, 0, -(value * value)],\n\t\t\t];\n\t\t\treturn this.context.createIIRFilter(\n\t\t\t\tcoefficients[0],\n\t\t\t\tcoefficients[1]\n\t\t\t);\n\t\t});\n\n\t\treturn nodes;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.offset90.dispose();\n\t\tthis._bank0.forEach((f) => f.disconnect());\n\t\tthis._bank1.forEach((f) => f.disconnect());\n\t\tthis._oneSampleDelay.disconnect();\n\t\treturn this;\n\t}\n}\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,4BAA4B;AACjD,SACCC,aAAa,EACbC,aAAa,QAEP,qCAAqC;AAE5C;;;;;;;;AAQA,OAAM,MAAOC,iBAAkB,SAAQD,aAAmC;EA8BzEE,YAAYC,OAAuC;IAClD,KAAK,CAACA,OAAO,CAAC;IA9BN,KAAAC,IAAI,GAAW,mBAAmB;IAElC,KAAAC,KAAK,GAAG,IAAIP,IAAI,CAAC;MAAEQ,OAAO,EAAE,IAAI,CAACA;IAAO,CAAE,CAAC;IAiBpD;;;IAGS,KAAAC,MAAM,GAAG,IAAIT,IAAI,CAAC;MAAEQ,OAAO,EAAE,IAAI,CAACA;IAAO,CAAE,CAAC;IAErD;;;IAGS,KAAAE,QAAQ,GAAG,IAAIV,IAAI,CAAC;MAAEQ,OAAO,EAAE,IAAI,CAACA;IAAO,CAAE,CAAC;IAKtD,MAAMG,kBAAkB,GAAG,CAC1B,SAAS,EAAE,eAAe,EAAE,cAAc,EAAE,eAAe,CAC3D;IACD,MAAMC,kBAAkB,GAAG,CAC1B,eAAe,EAAE,cAAc,EAAE,eAAe,EAAE,eAAe,CACjE;IAED,IAAI,CAACC,MAAM,GAAG,IAAI,CAACC,wBAAwB,CAACH,kBAAkB,CAAC;IAC/D,IAAI,CAACI,MAAM,GAAG,IAAI,CAACD,wBAAwB,CAACF,kBAAkB,CAAC;IAC/D,IAAI,CAACI,eAAe,GAAG,IAAI,CAACR,OAAO,CAACS,eAAe,CAClD,CAAC,GAAG,EAAE,GAAG,CAAC,EACV,CAAC,GAAG,EAAE,GAAG,CAAC,CACV;IAED;IACAhB,aAAa,CACZ,IAAI,CAACM,KAAK,EACV,GAAG,IAAI,CAACM,MAAM,EACd,IAAI,CAACG,eAAe,EACpB,IAAI,CAACP,MAAM,CACX;IACDR,aAAa,CAAC,IAAI,CAACM,KAAK,EAAE,GAAG,IAAI,CAACQ,MAAM,EAAE,IAAI,CAACL,QAAQ,CAAC;EACzD;EAEA;;;EAGQI,wBAAwBA,CAACI,UAAoB;IACpD,MAAMC,KAAK,GAAoBD,UAAU,CAACE,GAAG,CAAEC,KAAK,IAAI;MACvD,MAAMC,YAAY,GAAG,CACpB,CAACD,KAAK,GAAGA,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EACtB,CAAC,CAAC,EAAE,CAAC,EAAE,EAAEA,KAAK,GAAGA,KAAK,CAAC,CAAC,CACxB;MACD,OAAO,IAAI,CAACb,OAAO,CAACS,eAAe,CAClCK,YAAY,CAAC,CAAC,CAAC,EACfA,YAAY,CAAC,CAAC,CAAC,CACf;IACF,CAAC,CAAC;IAEF,OAAOH,KAAK;EACb;EAEAI,OAAOA,CAAA;IACN,KAAK,CAACA,OAAO,EAAE;IACf,IAAI,CAAChB,KAAK,CAACgB,OAAO,EAAE;IACpB,IAAI,CAACd,MAAM,CAACc,OAAO,EAAE;IACrB,IAAI,CAACb,QAAQ,CAACa,OAAO,EAAE;IACvB,IAAI,CAACV,MAAM,CAACW,OAAO,CAAEC,CAAC,IAAKA,CAAC,CAACC,UAAU,EAAE,CAAC;IAC1C,IAAI,CAACX,MAAM,CAACS,OAAO,CAAEC,CAAC,IAAKA,CAAC,CAACC,UAAU,EAAE,CAAC;IAC1C,IAAI,CAACV,eAAe,CAACU,UAAU,EAAE;IACjC,OAAO,IAAI;EACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}