{"ast":null,"code":"import { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck.js\";\nimport { assert } from \"../core/util/Debug.js\";\nimport { Signal } from \"./Signal.js\";\nimport { SignalOperator } from \"./SignalOperator.js\";\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport class WaveShaper extends SignalOperator {\n  constructor() {\n    const options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n    super(options);\n    this.name = \"WaveShaper\";\n    /**\n     * the waveshaper node\n     */\n    this._shaper = this.context.createWaveShaper();\n    /**\n     * The input to the waveshaper node.\n     */\n    this.input = this._shaper;\n    /**\n     * The output from the waveshaper node\n     */\n    this.output = this._shaper;\n    if (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n      this.curve = Float32Array.from(options.mapping);\n    } else if (isFunction(options.mapping)) {\n      this.setMap(options.mapping, options.length);\n    }\n  }\n  static getDefaults() {\n    return Object.assign(Signal.getDefaults(), {\n      length: 1024\n    });\n  }\n  /**\n   * Uses a mapping function to set the value of the curve.\n   * @param mapping The function used to define the values.\n   *                The mapping function take two arguments:\n   *                the first is the value at the current position\n   *                which goes from -1 to 1 over the number of elements\n   *                in the curve array. The second argument is the array position.\n   * @example\n   * const shaper = new Tone.WaveShaper();\n   * // map the input signal from [-1, 1] to [0, 10]\n   * shaper.setMap((val, index) => (val + 1) * 5);\n   */\n  setMap(mapping, length = 1024) {\n    const array = new Float32Array(length);\n    for (let i = 0, len = length; i < len; i++) {\n      const normalized = i / (len - 1) * 2 - 1;\n      array[i] = mapping(normalized, i);\n    }\n    this.curve = array;\n    return this;\n  }\n  /**\n   * The array to set as the waveshaper curve. For linear curves\n   * array length does not make much difference, but for complex curves\n   * longer arrays will provide smoother interpolation.\n   */\n  get curve() {\n    return this._shaper.curve;\n  }\n  set curve(mapping) {\n    this._shaper.curve = mapping;\n  }\n  /**\n   * Specifies what type of oversampling (if any) should be used when\n   * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n   */\n  get oversample() {\n    return this._shaper.oversample;\n  }\n  set oversample(oversampling) {\n    const isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n    assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n    this._shaper.oversample = oversampling;\n  }\n  /**\n   * Clean up.\n   */\n  dispose() {\n    super.dispose();\n    this._shaper.disconnect();\n    return this;\n  }\n}","map":{"version":3,"names":["optionsFromArguments","isArray","isFunction","assert","Signal","SignalOperator","WaveShaper","constructor","options","getDefaults","arguments","name","_shaper","context","createWaveShaper","input","output","mapping","Float32Array","curve","from","setMap","length","Object","assign","array","i","len","normalized","oversample","oversampling","isOverSampleType","some","str","includes","dispose","disconnect"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/signal/WaveShaper.ts"],"sourcesContent":["import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck.js\";\nimport { assert } from \"../core/util/Debug.js\";\nimport { Signal } from \"./Signal.js\";\nimport { SignalOperator } from \"./SignalOperator.js\";\n\nexport type WaveShaperMappingFn = (value: number, index?: number) => number;\n\ntype WaveShaperMapping = WaveShaperMappingFn | number[] | Float32Array;\n\ninterface WaveShaperOptions extends ToneAudioNodeOptions {\n\tmapping?: WaveShaperMapping;\n\tlength: number;\n\tcurve?: number[] | Float32Array;\n}\n\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport class WaveShaper extends SignalOperator<WaveShaperOptions> {\n\treadonly name: string = \"WaveShaper\";\n\n\t/**\n\t * the waveshaper node\n\t */\n\tprivate _shaper: WaveShaperNode = this.context.createWaveShaper();\n\n\t/**\n\t * The input to the waveshaper node.\n\t */\n\tinput = this._shaper;\n\n\t/**\n\t * The output from the waveshaper node\n\t */\n\toutput = this._shaper;\n\n\t/**\n\t * @param mapping The function used to define the values.\n\t *                The mapping function should take two arguments:\n\t *                the first is the value at the current position\n\t *                and the second is the array position.\n\t *                If the argument is an array, that array will be\n\t *                set as the wave shaping function. The input\n\t *                signal is an AudioRange [-1, 1] value and the output\n\t *                signal can take on any numerical values.\n\t *\n\t * @param length The length of the WaveShaperNode buffer.\n\t */\n\tconstructor(mapping?: WaveShaperMapping, length?: number);\n\tconstructor(options?: Partial<WaveShaperOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tWaveShaper.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"mapping\", \"length\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tif (\n\t\t\tisArray(options.mapping) ||\n\t\t\toptions.mapping instanceof Float32Array\n\t\t) {\n\t\t\tthis.curve = Float32Array.from(options.mapping);\n\t\t} else if (isFunction(options.mapping)) {\n\t\t\tthis.setMap(options.mapping, options.length);\n\t\t}\n\t}\n\n\tstatic getDefaults(): WaveShaperOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tlength: 1024,\n\t\t});\n\t}\n\n\t/**\n\t * Uses a mapping function to set the value of the curve.\n\t * @param mapping The function used to define the values.\n\t *                The mapping function take two arguments:\n\t *                the first is the value at the current position\n\t *                which goes from -1 to 1 over the number of elements\n\t *                in the curve array. The second argument is the array position.\n\t * @example\n\t * const shaper = new Tone.WaveShaper();\n\t * // map the input signal from [-1, 1] to [0, 10]\n\t * shaper.setMap((val, index) => (val + 1) * 5);\n\t */\n\tsetMap(mapping: WaveShaperMappingFn, length = 1024): this {\n\t\tconst array = new Float32Array(length);\n\t\tfor (let i = 0, len = length; i < len; i++) {\n\t\t\tconst normalized = (i / (len - 1)) * 2 - 1;\n\t\t\tarray[i] = mapping(normalized, i);\n\t\t}\n\t\tthis.curve = array;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The array to set as the waveshaper curve. For linear curves\n\t * array length does not make much difference, but for complex curves\n\t * longer arrays will provide smoother interpolation.\n\t */\n\tget curve(): Float32Array | null {\n\t\treturn this._shaper.curve;\n\t}\n\n\tset curve(mapping: Float32Array | null) {\n\t\tthis._shaper.curve = mapping;\n\t}\n\n\t/**\n\t * Specifies what type of oversampling (if any) should be used when\n\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\n\tset oversample(oversampling: OverSampleType) {\n\t\tconst isOverSampleType = [\"none\", \"2x\", \"4x\"].some((str) =>\n\t\t\tstr.includes(oversampling)\n\t\t);\n\t\tassert(\n\t\t\tisOverSampleType,\n\t\t\t\"oversampling must be either 'none', '2x', or '4x'\"\n\t\t);\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.disconnect();\n\t\treturn this;\n\t}\n}\n"],"mappings":"AACA,SAASA,oBAAoB,QAAQ,0BAA0B;AAC/D,SAASC,OAAO,EAAEC,UAAU,QAAQ,2BAA2B;AAC/D,SAASC,MAAM,QAAQ,uBAAuB;AAC9C,SAASC,MAAM,QAAQ,aAAa;AACpC,SAASC,cAAc,QAAQ,qBAAqB;AAYpD;;;;;;;;;;;AAWA,OAAM,MAAOC,UAAW,SAAQD,cAAiC;EAgChEE,YAAA;IACC,MAAMC,OAAO,GAAGR,oBAAoB,CACnCM,UAAU,CAACG,WAAW,EAAE,EACxBC,SAAS,EACT,CAAC,SAAS,EAAE,QAAQ,CAAC,CACrB;IACD,KAAK,CAACF,OAAO,CAAC;IArCN,KAAAG,IAAI,GAAW,YAAY;IAEpC;;;IAGQ,KAAAC,OAAO,GAAmB,IAAI,CAACC,OAAO,CAACC,gBAAgB,EAAE;IAEjE;;;IAGA,KAAAC,KAAK,GAAG,IAAI,CAACH,OAAO;IAEpB;;;IAGA,KAAAI,MAAM,GAAG,IAAI,CAACJ,OAAO;IAwBpB,IACCX,OAAO,CAACO,OAAO,CAACS,OAAO,CAAC,IACxBT,OAAO,CAACS,OAAO,YAAYC,YAAY,EACtC;MACD,IAAI,CAACC,KAAK,GAAGD,YAAY,CAACE,IAAI,CAACZ,OAAO,CAACS,OAAO,CAAC;IAChD,CAAC,MAAM,IAAIf,UAAU,CAACM,OAAO,CAACS,OAAO,CAAC,EAAE;MACvC,IAAI,CAACI,MAAM,CAACb,OAAO,CAACS,OAAO,EAAET,OAAO,CAACc,MAAM,CAAC;IAC7C;EACD;EAEA,OAAOb,WAAWA,CAAA;IACjB,OAAOc,MAAM,CAACC,MAAM,CAACpB,MAAM,CAACK,WAAW,EAAE,EAAE;MAC1Ca,MAAM,EAAE;KACR,CAAC;EACH;EAEA;;;;;;;;;;;;EAYAD,MAAMA,CAACJ,OAA4B,EAAEK,MAAM,GAAG,IAAI;IACjD,MAAMG,KAAK,GAAG,IAAIP,YAAY,CAACI,MAAM,CAAC;IACtC,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGL,MAAM,EAAEI,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC3C,MAAME,UAAU,GAAIF,CAAC,IAAIC,GAAG,GAAG,CAAC,CAAC,GAAI,CAAC,GAAG,CAAC;MAC1CF,KAAK,CAACC,CAAC,CAAC,GAAGT,OAAO,CAACW,UAAU,EAAEF,CAAC,CAAC;IAClC;IACA,IAAI,CAACP,KAAK,GAAGM,KAAK;IAClB,OAAO,IAAI;EACZ;EAEA;;;;;EAKA,IAAIN,KAAKA,CAAA;IACR,OAAO,IAAI,CAACP,OAAO,CAACO,KAAK;EAC1B;EAEA,IAAIA,KAAKA,CAACF,OAA4B;IACrC,IAAI,CAACL,OAAO,CAACO,KAAK,GAAGF,OAAO;EAC7B;EAEA;;;;EAIA,IAAIY,UAAUA,CAAA;IACb,OAAO,IAAI,CAACjB,OAAO,CAACiB,UAAU;EAC/B;EAEA,IAAIA,UAAUA,CAACC,YAA4B;IAC1C,MAAMC,gBAAgB,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,CAACC,IAAI,CAAEC,GAAG,IACtDA,GAAG,CAACC,QAAQ,CAACJ,YAAY,CAAC,CAC1B;IACD3B,MAAM,CACL4B,gBAAgB,EAChB,mDAAmD,CACnD;IACD,IAAI,CAACnB,OAAO,CAACiB,UAAU,GAAGC,YAAY;EACvC;EAEA;;;EAGAK,OAAOA,CAAA;IACN,KAAK,CAACA,OAAO,EAAE;IACf,IAAI,CAACvB,OAAO,CAACwB,UAAU,EAAE;IACzB,OAAO,IAAI;EACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}