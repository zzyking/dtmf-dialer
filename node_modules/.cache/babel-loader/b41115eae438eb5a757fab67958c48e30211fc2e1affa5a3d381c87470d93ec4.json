{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport { assert } from \"../../core/util/Debug.js\";\nimport { theWindow } from \"../../core/context/AudioContext.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\n/**\n * A wrapper around the MediaRecorder API. Unlike the rest of Tone.js, this module does not offer\n * any sample-accurate scheduling because it is not a feature of the MediaRecorder API.\n * This is only natively supported in Chrome and Firefox.\n * For a cross-browser shim, install (audio-recorder-polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n * @example\n * const recorder = new Tone.Recorder();\n * const synth = new Tone.Synth().connect(recorder);\n * // start recording\n * recorder.start();\n * // generate a few notes\n * synth.triggerAttackRelease(\"C3\", 0.5);\n * synth.triggerAttackRelease(\"C4\", 0.5, \"+1\");\n * synth.triggerAttackRelease(\"C5\", 0.5, \"+2\");\n * // wait for the notes to end and stop the recording\n * setTimeout(async () => {\n * \t// the recorded audio is returned as a blob\n * \tconst recording = await recorder.stop();\n * \t// download the recording by creating an anchor element and blob url\n * \tconst url = URL.createObjectURL(recording);\n * \tconst anchor = document.createElement(\"a\");\n * \tanchor.download = \"recording.webm\";\n * \tanchor.href = url;\n * \tanchor.click();\n * }, 4000);\n * @category Component\n */\nexport class Recorder extends ToneAudioNode {\n  constructor() {\n    const options = optionsFromArguments(Recorder.getDefaults(), arguments);\n    super(options);\n    this.name = \"Recorder\";\n    this.input = new Gain({\n      context: this.context\n    });\n    assert(Recorder.supported, \"Media Recorder API is not available\");\n    this._stream = this.context.createMediaStreamDestination();\n    this.input.connect(this._stream);\n    this._recorder = new MediaRecorder(this._stream.stream, {\n      mimeType: options.mimeType\n    });\n  }\n  static getDefaults() {\n    return ToneAudioNode.getDefaults();\n  }\n  /**\n   * The mime type is the format that the audio is encoded in. For Chrome\n   * that is typically webm encoded as \"vorbis\".\n   */\n  get mimeType() {\n    return this._recorder.mimeType;\n  }\n  /**\n   * Test if your platform supports the Media Recorder API. If it's not available,\n   * try installing this (polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n   */\n  static get supported() {\n    return theWindow !== null && Reflect.has(theWindow, \"MediaRecorder\");\n  }\n  /**\n   * Get the playback state of the Recorder, either \"started\", \"stopped\" or \"paused\"\n   */\n  get state() {\n    if (this._recorder.state === \"inactive\") {\n      return \"stopped\";\n    } else if (this._recorder.state === \"paused\") {\n      return \"paused\";\n    } else {\n      return \"started\";\n    }\n  }\n  /**\n   * Start the Recorder. Returns a promise which resolves\n   * when the recorder has started.\n   */\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(this.state !== \"started\", \"Recorder is already started\");\n      const startPromise = new Promise(done => {\n        const handleStart = () => {\n          this._recorder.removeEventListener(\"start\", handleStart, false);\n          done();\n        };\n        this._recorder.addEventListener(\"start\", handleStart, false);\n      });\n      this._recorder.start();\n      return yield startPromise;\n    });\n  }\n  /**\n   * Stop the recorder. Returns a promise with the recorded content until this point\n   * encoded as {@link mimeType}\n   */\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(this.state !== \"stopped\", \"Recorder is not started\");\n      const dataPromise = new Promise(done => {\n        const handleData = e => {\n          this._recorder.removeEventListener(\"dataavailable\", handleData, false);\n          done(e.data);\n        };\n        this._recorder.addEventListener(\"dataavailable\", handleData, false);\n      });\n      this._recorder.stop();\n      return yield dataPromise;\n    });\n  }\n  /**\n   * Pause the recorder\n   */\n  pause() {\n    assert(this.state === \"started\", \"Recorder must be started\");\n    this._recorder.pause();\n    return this;\n  }\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n    this._stream.disconnect();\n    return this;\n  }\n}","map":{"version":3,"names":["ToneAudioNode","Gain","assert","theWindow","optionsFromArguments","Recorder","constructor","options","getDefaults","arguments","name","input","context","supported","_stream","createMediaStreamDestination","connect","_recorder","MediaRecorder","stream","mimeType","Reflect","has","state","start","startPromise","Promise","done","handleStart","removeEventListener","addEventListener","stop","dataPromise","handleData","e","data","pause","dispose","disconnect"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/component/channel/Recorder.ts"],"sourcesContent":["import {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport { assert } from \"../../core/util/Debug.js\";\nimport { theWindow } from \"../../core/context/AudioContext.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { PlaybackState } from \"../../core/util/StateTimeline.js\";\n\nexport interface RecorderOptions extends ToneAudioNodeOptions {\n\tmimeType?: string;\n}\n\n/**\n * A wrapper around the MediaRecorder API. Unlike the rest of Tone.js, this module does not offer\n * any sample-accurate scheduling because it is not a feature of the MediaRecorder API.\n * This is only natively supported in Chrome and Firefox.\n * For a cross-browser shim, install (audio-recorder-polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n * @example\n * const recorder = new Tone.Recorder();\n * const synth = new Tone.Synth().connect(recorder);\n * // start recording\n * recorder.start();\n * // generate a few notes\n * synth.triggerAttackRelease(\"C3\", 0.5);\n * synth.triggerAttackRelease(\"C4\", 0.5, \"+1\");\n * synth.triggerAttackRelease(\"C5\", 0.5, \"+2\");\n * // wait for the notes to end and stop the recording\n * setTimeout(async () => {\n * \t// the recorded audio is returned as a blob\n * \tconst recording = await recorder.stop();\n * \t// download the recording by creating an anchor element and blob url\n * \tconst url = URL.createObjectURL(recording);\n * \tconst anchor = document.createElement(\"a\");\n * \tanchor.download = \"recording.webm\";\n * \tanchor.href = url;\n * \tanchor.click();\n * }, 4000);\n * @category Component\n */\nexport class Recorder extends ToneAudioNode<RecorderOptions> {\n\treadonly name = \"Recorder\";\n\n\t/**\n\t * Recorder uses the Media Recorder API\n\t */\n\tprivate _recorder: MediaRecorder;\n\n\t/**\n\t * MediaRecorder requires\n\t */\n\tprivate _stream: MediaStreamAudioDestinationNode;\n\n\treadonly input: Gain;\n\treadonly output: undefined;\n\n\tconstructor(options?: Partial<RecorderOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Recorder.getDefaults(), arguments);\n\t\tsuper(options);\n\n\t\tthis.input = new Gain({\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\tassert(Recorder.supported, \"Media Recorder API is not available\");\n\n\t\tthis._stream = this.context.createMediaStreamDestination();\n\t\tthis.input.connect(this._stream);\n\t\tthis._recorder = new MediaRecorder(this._stream.stream, {\n\t\t\tmimeType: options.mimeType,\n\t\t});\n\t}\n\n\tstatic getDefaults(): RecorderOptions {\n\t\treturn ToneAudioNode.getDefaults();\n\t}\n\n\t/**\n\t * The mime type is the format that the audio is encoded in. For Chrome\n\t * that is typically webm encoded as \"vorbis\".\n\t */\n\tget mimeType(): string {\n\t\treturn this._recorder.mimeType;\n\t}\n\n\t/**\n\t * Test if your platform supports the Media Recorder API. If it's not available,\n\t * try installing this (polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n\t */\n\tstatic get supported(): boolean {\n\t\treturn theWindow !== null && Reflect.has(theWindow, \"MediaRecorder\");\n\t}\n\n\t/**\n\t * Get the playback state of the Recorder, either \"started\", \"stopped\" or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\tif (this._recorder.state === \"inactive\") {\n\t\t\treturn \"stopped\";\n\t\t} else if (this._recorder.state === \"paused\") {\n\t\t\treturn \"paused\";\n\t\t} else {\n\t\t\treturn \"started\";\n\t\t}\n\t}\n\n\t/**\n\t * Start the Recorder. Returns a promise which resolves\n\t * when the recorder has started.\n\t */\n\tasync start() {\n\t\tassert(this.state !== \"started\", \"Recorder is already started\");\n\t\tconst startPromise = new Promise<void>((done) => {\n\t\t\tconst handleStart = () => {\n\t\t\t\tthis._recorder.removeEventListener(\"start\", handleStart, false);\n\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tthis._recorder.addEventListener(\"start\", handleStart, false);\n\t\t});\n\n\t\tthis._recorder.start();\n\t\treturn await startPromise;\n\t}\n\n\t/**\n\t * Stop the recorder. Returns a promise with the recorded content until this point\n\t * encoded as {@link mimeType}\n\t */\n\tasync stop(): Promise<Blob> {\n\t\tassert(this.state !== \"stopped\", \"Recorder is not started\");\n\t\tconst dataPromise: Promise<Blob> = new Promise((done) => {\n\t\t\tconst handleData = (e: BlobEvent) => {\n\t\t\t\tthis._recorder.removeEventListener(\n\t\t\t\t\t\"dataavailable\",\n\t\t\t\t\thandleData,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\n\t\t\t\tdone(e.data);\n\t\t\t};\n\n\t\t\tthis._recorder.addEventListener(\"dataavailable\", handleData, false);\n\t\t});\n\t\tthis._recorder.stop();\n\t\treturn await dataPromise;\n\t}\n\n\t/**\n\t * Pause the recorder\n\t */\n\tpause(): this {\n\t\tassert(this.state === \"started\", \"Recorder must be started\");\n\t\tthis._recorder.pause();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis._stream.disconnect();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}