{"ast":null,"code":"import { Tone } from \"../Tone.js\";\nimport { isUndef } from \"./TypeCheck.js\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\nexport class Emitter extends Tone {\n  constructor() {\n    super(...arguments);\n    this.name = \"Emitter\";\n  }\n  /**\n   * Bind a callback to a specific event.\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n  on(event, callback) {\n    // split the event\n    const events = event.split(/\\W+/);\n    events.forEach(eventName => {\n      if (isUndef(this._events)) {\n        this._events = {};\n      }\n      if (!this._events.hasOwnProperty(eventName)) {\n        this._events[eventName] = [];\n      }\n      this._events[eventName].push(callback);\n    });\n    return this;\n  }\n  /**\n   * Bind a callback which is only invoked once\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n  once(event, callback) {\n    const boundCallback = (...args) => {\n      // invoke the callback\n      callback(...args);\n      // remove the event\n      this.off(event, boundCallback);\n    };\n    this.on(event, boundCallback);\n    return this;\n  }\n  /**\n   * Remove the event listener.\n   * @param  event     The event to stop listening to.\n   * @param  callback  The callback which was bound to the event with Emitter.on.\n   *                   If no callback is given, all callbacks events are removed.\n   */\n  off(event, callback) {\n    const events = event.split(/\\W+/);\n    events.forEach(eventName => {\n      if (isUndef(this._events)) {\n        this._events = {};\n      }\n      if (this._events.hasOwnProperty(eventName)) {\n        if (isUndef(callback)) {\n          this._events[eventName] = [];\n        } else {\n          const eventList = this._events[eventName];\n          for (let i = eventList.length - 1; i >= 0; i--) {\n            if (eventList[i] === callback) {\n              eventList.splice(i, 1);\n            }\n          }\n        }\n      }\n    });\n    return this;\n  }\n  /**\n   * Invoke all of the callbacks bound to the event\n   * with any arguments passed in.\n   * @param  event  The name of the event.\n   * @param args The arguments to pass to the functions listening.\n   */\n  emit(event, ...args) {\n    if (this._events) {\n      if (this._events.hasOwnProperty(event)) {\n        const eventList = this._events[event].slice(0);\n        for (let i = 0, len = eventList.length; i < len; i++) {\n          eventList[i].apply(this, args);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Add Emitter functions (on/off/emit) to the object\n   */\n  static mixin(constr) {\n    // instance._events = {};\n    [\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n      const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n      Object.defineProperty(constr.prototype, name, property);\n    });\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this._events = undefined;\n    return this;\n  }\n}","map":{"version":3,"names":["Tone","isUndef","Emitter","constructor","name","on","event","callback","events","split","forEach","eventName","_events","hasOwnProperty","push","once","boundCallback","args","off","eventList","i","length","splice","emit","slice","len","apply","mixin","constr","property","Object","getOwnPropertyDescriptor","prototype","defineProperty","dispose","undefined"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/core/util/Emitter.ts"],"sourcesContent":["import { Tone } from \"../Tone.js\";\nimport { isUndef } from \"./TypeCheck.js\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\treadonly name: string = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t * Bind a callback to a specific event.\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach((eventName) => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Bind a callback which is only invoked once\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[]) => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove the event listener.\n\t * @param  event     The event to stop listening to.\n\t * @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                   If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach((eventName) => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(eventName)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[eventName] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[eventName];\n\t\t\t\t\tfor (let i = eventList.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke all of the callbacks bound to the event\n\t * with any arguments passed in.\n\t * @param  event  The name of the event.\n\t * @param args The arguments to pass to the functions listening.\n\t */\n\temit(event: EventType, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach((name) => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(\n\t\t\t\tEmitter.prototype,\n\t\t\t\tname\n\t\t\t) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}