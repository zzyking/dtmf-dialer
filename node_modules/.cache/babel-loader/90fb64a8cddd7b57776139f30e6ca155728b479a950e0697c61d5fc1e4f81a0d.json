{"ast":null,"code":"import { ToneWithContext } from \"../context/ToneWithContext.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Emitter } from \"../util/Emitter.js\";\nimport { noOp, readOnly } from \"../util/Interface.js\";\nimport { StateTimeline } from \"../util/StateTimeline.js\";\nimport { TickSource } from \"./TickSource.js\";\nimport { assertContextRunning } from \"../util/Debug.js\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock extends ToneWithContext {\n  constructor() {\n    const options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n    super(options);\n    this.name = \"Clock\";\n    /**\n     * The callback function to invoke at the scheduled tick.\n     */\n    this.callback = noOp;\n    /**\n     * The last time the loop callback was invoked\n     */\n    this._lastUpdate = 0;\n    /**\n     * Keep track of the playback state\n     */\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * Context bound reference to the _loop method\n     * This is necessary to remove the event in the end.\n     */\n    this._boundLoop = this._loop.bind(this);\n    this.callback = options.callback;\n    this._tickSource = new TickSource({\n      context: this.context,\n      frequency: options.frequency,\n      units: options.units\n    });\n    this._lastUpdate = 0;\n    this.frequency = this._tickSource.frequency;\n    readOnly(this, \"frequency\");\n    // add an initial state\n    this._state.setStateAtTime(\"stopped\", 0);\n    // bind a callback to the worker thread\n    this.context.on(\"tick\", this._boundLoop);\n  }\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      callback: noOp,\n      frequency: 1,\n      units: \"hertz\"\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n  get state() {\n    return this._state.getValueAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset  Where the tick counter starts counting from.\n   */\n  start(time, offset) {\n    // make sure the context is running\n    assertContextRunning(this.context);\n    // start the loop\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n      this._tickSource.start(computedTime, offset);\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"start\", computedTime, offset);\n      }\n    }\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   * @example\n   * const clock = new Tone.Clock(time => {\n   * \tconsole.log(time);\n   * }, 1);\n   * clock.start();\n   * // stop the clock after 10 seconds\n   * clock.stop(\"+10\");\n   */\n  stop(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"stop\", computedTime);\n    this._state.cancel(computedTime);\n    this._state.setStateAtTime(\"stopped\", computedTime);\n    this._tickSource.stop(computedTime);\n    if (computedTime < this._lastUpdate) {\n      this.emit(\"stop\", computedTime);\n    }\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n      this._tickSource.pause(computedTime);\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"pause\", computedTime);\n      }\n    }\n    return this;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked.\n   */\n  get ticks() {\n    return Math.ceil(this.getTicksAtTime(this.now()));\n  }\n  set ticks(t) {\n    this._tickSource.ticks = t;\n  }\n  /**\n   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n   */\n  get seconds() {\n    return this._tickSource.seconds;\n  }\n  set seconds(s) {\n    this._tickSource.seconds = s;\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n  getSecondsAtTime(time) {\n    return this._tickSource.getSecondsAtTime(time);\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n  setTicksAtTime(ticks, time) {\n    this._tickSource.setTicksAtTime(ticks, time);\n    return this;\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n  getTimeOfTick(tick, before = this.now()) {\n    return this._tickSource.getTimeOfTick(tick, before);\n  }\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n  getTicksAtTime(time) {\n    return this._tickSource.getTicksAtTime(time);\n  }\n  /**\n   * Get the time of the next tick\n   * @param  offset The tick number.\n   */\n  nextTickTime(offset, when) {\n    const computedTime = this.toSeconds(when);\n    const currentTick = this.getTicksAtTime(computedTime);\n    return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n  }\n  /**\n   * The scheduling loop.\n   */\n  _loop() {\n    const startTime = this._lastUpdate;\n    const endTime = this.now();\n    this._lastUpdate = endTime;\n    this.log(\"loop\", startTime, endTime);\n    if (startTime !== endTime) {\n      // the state change events\n      this._state.forEachBetween(startTime, endTime, e => {\n        switch (e.state) {\n          case \"started\":\n            const offset = this._tickSource.getTicksAtTime(e.time);\n            this.emit(\"start\", e.time, offset);\n            break;\n          case \"stopped\":\n            if (e.time !== 0) {\n              this.emit(\"stop\", e.time);\n            }\n            break;\n          case \"paused\":\n            this.emit(\"pause\", e.time);\n            break;\n        }\n      });\n      // the tick callbacks\n      this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n        this.callback(time, ticks);\n      });\n    }\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   * @example\n   * const clock = new Tone.Clock();\n   * clock.start(\"+0.1\");\n   * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n   */\n  getStateAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    return this._state.getValueAtTime(computedTime);\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this.context.off(\"tick\", this._boundLoop);\n    this._tickSource.dispose();\n    this._state.dispose();\n    return this;\n  }\n}\nEmitter.mixin(Clock);","map":{"version":3,"names":["ToneWithContext","optionsFromArguments","Emitter","noOp","readOnly","StateTimeline","TickSource","assertContextRunning","Clock","constructor","options","getDefaults","arguments","name","callback","_lastUpdate","_state","_boundLoop","_loop","bind","_tickSource","context","frequency","units","setStateAtTime","on","Object","assign","state","getValueAtTime","now","start","time","offset","computedTime","toSeconds","log","emit","stop","cancel","pause","ticks","Math","ceil","getTicksAtTime","t","seconds","s","getSecondsAtTime","setTicksAtTime","getTimeOfTick","tick","before","nextTickTime","when","currentTick","startTime","endTime","forEachBetween","e","forEachTickBetween","getStateAtTime","dispose","off","mixin"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/core/clock/Clock.ts"],"sourcesContent":["import {\n\tToneWithContext,\n\tToneWithContextOptions,\n} from \"../context/ToneWithContext.js\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Emitter } from \"../util/Emitter.js\";\nimport { noOp, readOnly } from \"../util/Interface.js\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline.js\";\nimport { TickSignal } from \"./TickSignal.js\";\nimport { TickSource } from \"./TickSource.js\";\nimport { assertContextRunning } from \"../util/Debug.js\";\n\ntype ClockCallback = (time: Seconds, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: Hertz;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock<TypeName extends \"bpm\" | \"hertz\" = \"hertz\">\n\textends ToneWithContext<ClockOptions>\n\timplements Emitter<ClockEvent>\n{\n\treadonly name: string = \"Clock\";\n\n\t/**\n\t * The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t * The tick counter\n\t */\n\tprivate _tickSource: TickSource<TypeName>;\n\n\t/**\n\t * The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate = 0;\n\n\t/**\n\t * Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t * The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<TypeName>;\n\n\t/**\n\t * @param callback The callback to be invoked with the time of the audio event\n\t * @param frequency The rate of the callback\n\t */\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\n\t\t\t\"callback\",\n\t\t\t\"frequency\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is running\n\t\tassertContextRunning(this.context);\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t * @example\n\t * const clock = new Tone.Clock(time => {\n\t * \tconsole.log(time);\n\t * }, 1);\n\t * clock.start();\n\t * // stop the clock after 10 seconds\n\t * clock.stop(\"+10\");\n\t */\n\tstop(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"stop\", computedTime);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\treturn this._tickSource.getTimeOfTick(tick, before);\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  offset The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(\n\t\t\tcurrentTick + offset,\n\t\t\tcomputedTime\n\t\t);\n\t}\n\n\t/**\n\t * The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\t\tthis.log(\"loop\", startTime, endTime);\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, (e) => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\":\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\":\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\":\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(\n\t\t\t\tstartTime,\n\t\t\t\tendTime,\n\t\t\t\t(time, ticks) => {\n\t\t\t\t\tthis.callback(time, ticks);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * const clock = new Tone.Clock();\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (\n\t\tevent: ClockEvent,\n\t\tcallback?: ((...args: any[]) => void) | undefined\n\t) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}