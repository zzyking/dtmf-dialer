{"ast":null,"code":"import { dbToGain, gainToDb } from \"../type/Conversions.js\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\nimport { ToneWithContext } from \"./ToneWithContext.js\";\nimport { EQ } from \"../util/Math.js\";\nimport { assert, assertRange } from \"../util/Debug.js\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param extends ToneWithContext {\n  constructor() {\n    const options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n    super(options);\n    this.name = \"Param\";\n    this.overridden = false;\n    /**\n     * The minimum output value\n     */\n    this._minOutput = 1e-7;\n    assert(isDefined(options.param) && (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n    while (!isAudioParam(options.param)) {\n      options.param = options.param._param;\n    }\n    this._swappable = isDefined(options.swappable) ? options.swappable : false;\n    if (this._swappable) {\n      this.input = this.context.createGain();\n      // initialize\n      this._param = options.param;\n      this.input.connect(this._param);\n    } else {\n      this._param = this.input = options.param;\n    }\n    this._events = new Timeline(1000);\n    this._initialValue = this._param.defaultValue;\n    this.units = options.units;\n    this.convert = options.convert;\n    this._minValue = options.minValue;\n    this._maxValue = options.maxValue;\n    // if the value is defined, set it immediately\n    if (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n      this.setValueAtTime(options.value, 0);\n    }\n  }\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      convert: true,\n      units: \"number\"\n    });\n  }\n  get value() {\n    const now = this.now();\n    return this.getValueAtTime(now);\n  }\n  set value(value) {\n    this.cancelScheduledValues(this.now());\n    this.setValueAtTime(value, this.now());\n  }\n  get minValue() {\n    // if it's not the default minValue, return it\n    if (isDefined(this._minValue)) {\n      return this._minValue;\n    } else if (this.units === \"time\" || this.units === \"frequency\" || this.units === \"normalRange\" || this.units === \"positive\" || this.units === \"transportTime\" || this.units === \"ticks\" || this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n      return 0;\n    } else if (this.units === \"audioRange\") {\n      return -1;\n    } else if (this.units === \"decibels\") {\n      return -Infinity;\n    } else {\n      return this._param.minValue;\n    }\n  }\n  get maxValue() {\n    if (isDefined(this._maxValue)) {\n      return this._maxValue;\n    } else if (this.units === \"normalRange\" || this.units === \"audioRange\") {\n      return 1;\n    } else {\n      return this._param.maxValue;\n    }\n  }\n  /**\n   * Type guard based on the unit name\n   */\n  _is(arg, type) {\n    return this.units === type;\n  }\n  /**\n   * Make sure the value is always in the defined range\n   */\n  _assertRange(value) {\n    if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n      assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n    }\n    return value;\n  }\n  /**\n   * Convert the given value from the type specified by Param.units\n   * into the destination value (such as Gain or Frequency).\n   */\n  _fromType(val) {\n    if (this.convert && !this.overridden) {\n      if (this._is(val, \"time\")) {\n        return this.toSeconds(val);\n      } else if (this._is(val, \"decibels\")) {\n        return dbToGain(val);\n      } else if (this._is(val, \"frequency\")) {\n        return this.toFrequency(val);\n      } else {\n        return val;\n      }\n    } else if (this.overridden) {\n      // if it's overridden, should only schedule 0s\n      return 0;\n    } else {\n      return val;\n    }\n  }\n  /**\n   * Convert the parameters value into the units specified by Param.units.\n   */\n  _toType(val) {\n    if (this.convert && this.units === \"decibels\") {\n      return gainToDb(val);\n    } else {\n      return val;\n    }\n  }\n  //-------------------------------------\n  // ABSTRACT PARAM INTERFACE\n  // all docs are generated from ParamInterface.ts\n  //-------------------------------------\n  setValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n    const numericValue = this._fromType(value);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n    this._assertRange(numericValue);\n    this.log(this.units, \"setValueAtTime\", value, computedTime);\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: numericValue\n    });\n    this._param.setValueAtTime(numericValue, computedTime);\n    return this;\n  }\n  getValueAtTime(time) {\n    const computedTime = Math.max(this.toSeconds(time), 0);\n    const after = this._events.getAfter(computedTime);\n    const before = this._events.get(computedTime);\n    let value = this._initialValue;\n    // if it was set by\n    if (before === null) {\n      value = this._initialValue;\n    } else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n      const previous = this._events.getBefore(before.time);\n      let previousVal;\n      if (previous === null) {\n        previousVal = this._initialValue;\n      } else {\n        previousVal = previous.value;\n      }\n      if (before.type === \"setTargetAtTime\") {\n        value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n      }\n    } else if (after === null) {\n      value = before.value;\n    } else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n      let beforeValue = before.value;\n      if (before.type === \"setTargetAtTime\") {\n        const previous = this._events.getBefore(before.time);\n        if (previous === null) {\n          beforeValue = this._initialValue;\n        } else {\n          beforeValue = previous.value;\n        }\n      }\n      if (after.type === \"linearRampToValueAtTime\") {\n        value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      } else {\n        value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      }\n    } else {\n      value = before.value;\n    }\n    return this._toType(value);\n  }\n  setRampPoint(time) {\n    time = this.toSeconds(time);\n    let currentVal = this.getValueAtTime(time);\n    this.cancelAndHoldAtTime(time);\n    if (this._fromType(currentVal) === 0) {\n      currentVal = this._toType(this._minOutput);\n    }\n    this.setValueAtTime(currentVal, time);\n    return this;\n  }\n  linearRampToValueAtTime(value, endTime) {\n    const numericValue = this._fromType(value);\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n    this._assertRange(numericValue);\n    this._events.add({\n      time: computedTime,\n      type: \"linearRampToValueAtTime\",\n      value: numericValue\n    });\n    this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n    this._param.linearRampToValueAtTime(numericValue, computedTime);\n    return this;\n  }\n  exponentialRampToValueAtTime(value, endTime) {\n    let numericValue = this._fromType(value);\n    // the value can't be 0\n    numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n    this._assertRange(numericValue);\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n    // store the event\n    this._events.add({\n      time: computedTime,\n      type: \"exponentialRampToValueAtTime\",\n      value: numericValue\n    });\n    this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n    this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n    return this;\n  }\n  exponentialRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n  linearRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n  targetRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialApproachValueAtTime(value, startTime, rampTime);\n    return this;\n  }\n  exponentialApproachValueAtTime(value, time, rampTime) {\n    time = this.toSeconds(time);\n    rampTime = this.toSeconds(rampTime);\n    const timeConstant = Math.log(rampTime + 1) / Math.log(200);\n    this.setTargetAtTime(value, time, timeConstant);\n    // at 90% start a linear ramp to the final value\n    this.cancelAndHoldAtTime(time + rampTime * 0.9);\n    this.linearRampToValueAtTime(value, time + rampTime);\n    return this;\n  }\n  setTargetAtTime(value, startTime, timeConstant) {\n    const numericValue = this._fromType(value);\n    // The value will never be able to approach without timeConstant > 0.\n    assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n    const computedTime = this.toSeconds(startTime);\n    this._assertRange(numericValue);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n    this._events.add({\n      constant: timeConstant,\n      time: computedTime,\n      type: \"setTargetAtTime\",\n      value: numericValue\n    });\n    this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n    this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n    return this;\n  }\n  setValueCurveAtTime(values, startTime, duration, scaling = 1) {\n    duration = this.toSeconds(duration);\n    startTime = this.toSeconds(startTime);\n    const startingValue = this._fromType(values[0]) * scaling;\n    this.setValueAtTime(this._toType(startingValue), startTime);\n    const segTime = duration / (values.length - 1);\n    for (let i = 1; i < values.length; i++) {\n      const numericValue = this._fromType(values[i]) * scaling;\n      this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n    }\n    return this;\n  }\n  cancelScheduledValues(time) {\n    const computedTime = this.toSeconds(time);\n    assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n    this._events.cancel(computedTime);\n    this._param.cancelScheduledValues(computedTime);\n    this.log(this.units, \"cancelScheduledValues\", computedTime);\n    return this;\n  }\n  cancelAndHoldAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    const valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n    // remove the schedule events\n    assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n    this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n    // if there is an event at the given computedTime\n    // and that even is not a \"set\"\n    const before = this._events.get(computedTime);\n    const after = this._events.getAfter(computedTime);\n    if (before && EQ(before.time, computedTime)) {\n      // remove everything after\n      if (after) {\n        this._param.cancelScheduledValues(after.time);\n        this._events.cancel(after.time);\n      } else {\n        this._param.cancelAndHoldAtTime(computedTime);\n        this._events.cancel(computedTime + this.sampleTime);\n      }\n    } else if (after) {\n      this._param.cancelScheduledValues(after.time);\n      // cancel the next event(s)\n      this._events.cancel(after.time);\n      if (after.type === \"linearRampToValueAtTime\") {\n        this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      } else if (after.type === \"exponentialRampToValueAtTime\") {\n        this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      }\n    }\n    // set the value at the given time\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: valueAtTime\n    });\n    this._param.setValueAtTime(valueAtTime, computedTime);\n    return this;\n  }\n  rampTo(value, rampTime = 0.1, startTime) {\n    if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n      this.exponentialRampTo(value, rampTime, startTime);\n    } else {\n      this.linearRampTo(value, rampTime, startTime);\n    }\n    return this;\n  }\n  /**\n   * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n   * The applied values will start at the context's current time and schedule\n   * all of the events which are scheduled on this Param onto the passed in param.\n   */\n  apply(param) {\n    const now = this.context.currentTime;\n    // set the param's value at the current time and schedule everything else\n    param.setValueAtTime(this.getValueAtTime(now), now);\n    // if the previous event was a curve, then set the rest of it\n    const previousEvent = this._events.get(now);\n    if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n      // approx it until the next event with linear ramps\n      const nextEvent = this._events.getAfter(previousEvent.time);\n      // or for 2 seconds if there is no event\n      const endTime = nextEvent ? nextEvent.time : now + 2;\n      const subdivisions = (endTime - now) / 10;\n      for (let i = now; i < endTime; i += subdivisions) {\n        param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n      }\n    }\n    this._events.forEachAfter(this.context.currentTime, event => {\n      if (event.type === \"cancelScheduledValues\") {\n        param.cancelScheduledValues(event.time);\n      } else if (event.type === \"setTargetAtTime\") {\n        param.setTargetAtTime(event.value, event.time, event.constant);\n      } else {\n        param[event.type](event.value, event.time);\n      }\n    });\n    return this;\n  }\n  /**\n   * Replace the Param's internal AudioParam. Will apply scheduled curves\n   * onto the parameter and replace the connections.\n   */\n  setParam(param) {\n    assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n    const input = this.input;\n    input.disconnect(this._param);\n    this.apply(param);\n    this._param = param;\n    input.connect(this._param);\n    return this;\n  }\n  dispose() {\n    super.dispose();\n    this._events.dispose();\n    return this;\n  }\n  get defaultValue() {\n    return this._toType(this._param.defaultValue);\n  }\n  //-------------------------------------\n  // \tAUTOMATION CURVE CALCULATIONS\n  // \tMIT License, copyright (c) 2014 Jordan Santell\n  //-------------------------------------\n  // Calculates the the value along the curve produced by setTargetAtTime\n  _exponentialApproach(t0, v0, v1, timeConstant, t) {\n    return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n  }\n  // Calculates the the value along the curve produced by linearRampToValueAtTime\n  _linearInterpolate(t0, v0, t1, v1, t) {\n    return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n  }\n  // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n  _exponentialInterpolate(t0, v0, t1, v1, t) {\n    return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n  }\n}","map":{"version":3,"names":["dbToGain","gainToDb","isAudioParam","optionsFromArguments","Timeline","isDefined","ToneWithContext","EQ","assert","assertRange","Param","constructor","options","getDefaults","arguments","name","overridden","_minOutput","param","_param","_swappable","swappable","input","context","createGain","connect","_events","_initialValue","defaultValue","units","convert","_minValue","minValue","_maxValue","maxValue","value","_toType","setValueAtTime","Object","assign","now","getValueAtTime","cancelScheduledValues","Infinity","_is","arg","type","_assertRange","_fromType","val","toSeconds","toFrequency","time","computedTime","numericValue","isFinite","JSON","stringify","log","add","Math","max","after","getAfter","before","get","previous","getBefore","previousVal","_exponentialApproach","constant","beforeValue","_linearInterpolate","_exponentialInterpolate","setRampPoint","currentVal","cancelAndHoldAtTime","linearRampToValueAtTime","endTime","exponentialRampToValueAtTime","exponentialRampTo","rampTime","startTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","timeConstant","setTargetAtTime","setValueCurveAtTime","values","duration","scaling","startingValue","segTime","length","i","cancel","valueAtTime","sampleTime","rampTo","apply","currentTime","previousEvent","nextEvent","subdivisions","forEachAfter","event","setParam","disconnect","dispose","t0","v0","v1","t","exp","t1","pow"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/core/context/Param.ts"],"sourcesContent":["import { AbstractParam } from \"../context/AbstractParam.js\";\nimport { dbToGain, gainToDb } from \"../type/Conversions.js\";\nimport {\n\tDecibels,\n\tFrequency,\n\tPositive,\n\tTime,\n\tUnitMap,\n\tUnitName,\n} from \"../type/Units.js\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext.js\";\nimport { EQ } from \"../util/Math.js\";\nimport { assert, assertRange } from \"../util/Debug.js\";\n\nexport interface ParamOptions<TypeName extends UnitName>\n\textends ToneWithContextOptions {\n\tunits: TypeName;\n\tvalue?: UnitMap[TypeName];\n\tparam: AudioParam | Param<TypeName>;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n\tswappable?: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType =\n\t| \"linearRampToValueAtTime\"\n\t| \"exponentialRampToValueAtTime\"\n\t| \"setValueAtTime\"\n\t| \"setTargetAtTime\"\n\t| \"cancelScheduledValues\";\n\ninterface TargetAutomationEvent {\n\ttype: \"setTargetAtTime\";\n\ttime: number;\n\tvalue: number;\n\tconstant: number;\n}\n\ninterface NormalAutomationEvent {\n\ttype: Exclude<AutomationType, \"setTargetAtTime\">;\n\ttime: number;\n\tvalue: number;\n}\n/**\n * The events on the automation\n */\nexport type AutomationEvent = NormalAutomationEvent | TargetAutomationEvent;\n\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param<TypeName extends UnitName = \"number\">\n\textends ToneWithContext<ParamOptions<TypeName>>\n\timplements AbstractParam<TypeName>\n{\n\treadonly name: string = \"Param\";\n\n\treadonly input: GainNode | AudioParam;\n\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t * The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t * The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t * The minimum output value\n\t */\n\tprivate _minOutput = 1e-7;\n\n\t/**\n\t * Private reference to the min and max values if passed into the constructor\n\t */\n\tprivate readonly _minValue?: number;\n\tprivate readonly _maxValue?: number;\n\n\t/**\n\t * If the underlying AudioParam can be swapped out\n\t * using the setParam method.\n\t */\n\tprotected readonly _swappable: boolean;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\tconstructor(param: AudioParam, units?: TypeName, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions<TypeName>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\n\t\t\t\"param\",\n\t\t\t\"units\",\n\t\t\t\"convert\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tassert(\n\t\t\tisDefined(options.param) &&\n\t\t\t\t(isAudioParam(options.param) || options.param instanceof Param),\n\t\t\t\"param must be an AudioParam\"\n\t\t);\n\n\t\twhile (!isAudioParam(options.param)) {\n\t\t\toptions.param = options.param._param;\n\t\t}\n\n\t\tthis._swappable = isDefined(options.swappable)\n\t\t\t? options.swappable\n\t\t\t: false;\n\t\tif (this._swappable) {\n\t\t\tthis.input = this.context.createGain();\n\t\t\t// initialize\n\t\t\tthis._param = options.param;\n\t\t\tthis.input.connect(this._param);\n\t\t} else {\n\t\t\tthis._param = this.input = options.param;\n\t\t}\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.defaultValue;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\t\tthis._minValue = options.minValue;\n\t\tthis._maxValue = options.maxValue;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (\n\t\t\tisDefined(options.value) &&\n\t\t\toptions.value !== this._toType(this._initialValue)\n\t\t) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ParamOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions<any>);\n\t}\n\n\tget value(): UnitMap[TypeName] {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value) {\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\t// if it's not the default minValue, return it\n\t\tif (isDefined(this._minValue)) {\n\t\t\treturn this._minValue;\n\t\t} else if (\n\t\t\tthis.units === \"time\" ||\n\t\t\tthis.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" ||\n\t\t\tthis.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" ||\n\t\t\tthis.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" ||\n\t\t\tthis.units === \"hertz\" ||\n\t\t\tthis.units === \"samples\"\n\t\t) {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (isDefined(this._maxValue)) {\n\t\t\treturn this._maxValue;\n\t\t} else if (\n\t\t\tthis.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\"\n\t\t) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t * Make sure the value is always in the defined range\n\t */\n\tprivate _assertRange(value: number): number {\n\t\tif (isDefined(this.maxValue) && isDefined(this.minValue)) {\n\t\t\tassertRange(\n\t\t\t\tvalue,\n\t\t\t\tthis._fromType(this.minValue),\n\t\t\t\tthis._fromType(this.maxValue)\n\t\t\t);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Convert the given value from the type specified by Param.units\n\t * into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else if (this.overridden) {\n\t\t\t// if it's overridden, should only schedule 0s\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn val as UnitMap[TypeName];\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tassert(\n\t\t\tisFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`\n\t\t);\n\t\tthis._assertRange(numericValue);\n\t\tthis.log(this.units, \"setValueAtTime\", value, computedTime);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis._param.setValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): UnitMap[TypeName] {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (\n\t\t\tbefore.type === \"setTargetAtTime\" &&\n\t\t\t(after === null || after.type === \"setValueAtTime\")\n\t\t) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tvalue = this._exponentialApproach(\n\t\t\t\t\tbefore.time,\n\t\t\t\t\tpreviousVal,\n\t\t\t\t\tbefore.value,\n\t\t\t\t\tbefore.constant,\n\t\t\t\t\tcomputedTime\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (\n\t\t\tafter.type === \"linearRampToValueAtTime\" ||\n\t\t\tafter.type === \"exponentialRampToValueAtTime\"\n\t\t) {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tvalue = this._linearInterpolate(\n\t\t\t\t\tbefore.time,\n\t\t\t\t\tbeforeValue,\n\t\t\t\t\tafter.time,\n\t\t\t\t\tafter.value,\n\t\t\t\t\tcomputedTime\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(\n\t\t\t\t\tbefore.time,\n\t\t\t\t\tbeforeValue,\n\t\t\t\t\tafter.time,\n\t\t\t\t\tafter.value,\n\t\t\t\t\tcomputedTime\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(\n\t\t\tisFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`\n\t\t);\n\t\tthis._assertRange(numericValue);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"linearRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(\n\t\tvalue: UnitMap[TypeName],\n\t\tendTime: Time\n\t): this {\n\t\tlet numericValue = this._fromType(value);\n\t\t// the value can't be 0\n\t\tnumericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n\t\tthis._assertRange(numericValue);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(\n\t\t\tisFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`\n\t\t);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"exponentialRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(\n\t\t\tthis.units,\n\t\t\t\"exponentialRampToValueAtTime\",\n\t\t\tvalue,\n\t\t\tcomputedTime\n\t\t);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time,\n\t\tstartTime?: Time\n\t): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(\n\t\t\tvalue,\n\t\t\tstartTime + this.toSeconds(rampTime)\n\t\t);\n\t\treturn this;\n\t}\n\n\tlinearRampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time,\n\t\tstartTime?: Time\n\t): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(\n\t\t\tvalue,\n\t\t\tstartTime + this.toSeconds(rampTime)\n\t\t);\n\t\treturn this;\n\t}\n\n\ttargetRampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time,\n\t\tstartTime?: Time\n\t): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(\n\t\tvalue: UnitMap[TypeName],\n\t\ttime: Time,\n\t\trampTime: Time\n\t): this {\n\t\ttime = this.toSeconds(time);\n\t\trampTime = this.toSeconds(rampTime);\n\t\tconst timeConstant = Math.log(rampTime + 1) / Math.log(200);\n\t\tthis.setTargetAtTime(value, time, timeConstant);\n\t\t// at 90% start a linear ramp to the final value\n\t\tthis.cancelAndHoldAtTime(time + rampTime * 0.9);\n\t\tthis.linearRampToValueAtTime(value, time + rampTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(\n\t\tvalue: UnitMap[TypeName],\n\t\tstartTime: Time,\n\t\ttimeConstant: Positive\n\t): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tassert(\n\t\t\tisFinite(timeConstant) && timeConstant > 0,\n\t\t\t\"timeConstant must be a number greater than 0\"\n\t\t);\n\t\tconst computedTime = this.toSeconds(startTime);\n\t\tthis._assertRange(numericValue);\n\t\tassert(\n\t\t\tisFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`\n\t\t);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setTargetAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(\n\t\t\tthis.units,\n\t\t\t\"setTargetAtTime\",\n\t\t\tvalue,\n\t\t\tcomputedTime,\n\t\t\ttimeConstant\n\t\t);\n\t\tthis._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(\n\t\tvalues: UnitMap[TypeName][],\n\t\tstartTime: Time,\n\t\tduration: Time,\n\t\tscaling = 1\n\t): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(\n\t\t\t\tthis._toType(numericValue),\n\t\t\t\tstartTime + i * segTime\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tassert(\n\t\t\tisFinite(computedTime),\n\t\t\t`Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`\n\t\t);\n\t\tthis._events.cancel(computedTime);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\t\tthis.log(this.units, \"cancelScheduledValues\", computedTime);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n\t\t// remove the schedule events\n\t\tassert(\n\t\t\tisFinite(computedTime),\n\t\t\t`Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`\n\t\t);\n\n\t\tthis.log(\n\t\t\tthis.units,\n\t\t\t\"cancelAndHoldAtTime\",\n\t\t\tcomputedTime,\n\t\t\t\"value=\" + valueAtTime\n\t\t);\n\n\t\t// if there is an event at the given computedTime\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(computedTime);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tif (before && EQ(before.time, computedTime)) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._param.cancelAndHoldAtTime(computedTime);\n\t\t\t\tthis._events.cancel(computedTime + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tthis.linearRampToValueAtTime(\n\t\t\t\t\tthis._toType(valueAtTime),\n\t\t\t\t\tcomputedTime\n\t\t\t\t);\n\t\t\t} else if (after.type === \"exponentialRampToValueAtTime\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(\n\t\t\t\t\tthis._toType(valueAtTime),\n\t\t\t\t\tcomputedTime\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, computedTime);\n\t\treturn this;\n\t}\n\n\trampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time = 0.1,\n\t\tstartTime?: Time\n\t): this {\n\t\tif (\n\t\t\tthis.units === \"frequency\" ||\n\t\t\tthis.units === \"bpm\" ||\n\t\t\tthis.units === \"decibels\"\n\t\t) {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n\t * The applied values will start at the context's current time and schedule\n\t * all of the events which are scheduled on this Param onto the passed in param.\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tconst now = this.context.currentTime;\n\t\t// set the param's value at the current time and schedule everything else\n\t\tparam.setValueAtTime(this.getValueAtTime(now) as number, now);\n\t\t// if the previous event was a curve, then set the rest of it\n\t\tconst previousEvent = this._events.get(now);\n\t\tif (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n\t\t\t// approx it until the next event with linear ramps\n\t\t\tconst nextEvent = this._events.getAfter(previousEvent.time);\n\t\t\t// or for 2 seconds if there is no event\n\t\t\tconst endTime = nextEvent ? nextEvent.time : now + 2;\n\t\t\tconst subdivisions = (endTime - now) / 10;\n\t\t\tfor (let i = now; i < endTime; i += subdivisions) {\n\t\t\t\tparam.linearRampToValueAtTime(\n\t\t\t\t\tthis.getValueAtTime(i) as number,\n\t\t\t\t\ti\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tthis._events.forEachAfter(this.context.currentTime, (event) => {\n\t\t\tif (event.type === \"cancelScheduledValues\") {\n\t\t\t\tparam.cancelScheduledValues(event.time);\n\t\t\t} else if (event.type === \"setTargetAtTime\") {\n\t\t\t\tparam.setTargetAtTime(event.value, event.time, event.constant);\n\t\t\t} else {\n\t\t\t\tparam[event.type](event.value, event.time);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replace the Param's internal AudioParam. Will apply scheduled curves\n\t * onto the parameter and replace the connections.\n\t */\n\tsetParam(param: AudioParam): this {\n\t\tassert(\n\t\t\tthis._swappable,\n\t\t\t\"The Param must be assigned as 'swappable' in the constructor\"\n\t\t);\n\t\tconst input = this.input as GainNode;\n\t\tinput.disconnect(this._param);\n\t\tthis.apply(param);\n\t\tthis._param = param;\n\t\tinput.connect(this._param);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\tget defaultValue(): UnitMap[TypeName] {\n\t\treturn this._toType(this._param.defaultValue);\n\t}\n\n\t//-------------------------------------\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t//-------------------------------------\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(\n\t\tt0: number,\n\t\tv0: number,\n\t\tv1: number,\n\t\ttimeConstant: number,\n\t\tt: number\n\t): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(\n\t\tt0: number,\n\t\tv0: number,\n\t\tt1: number,\n\t\tv1: number,\n\t\tt: number\n\t): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(\n\t\tt0: number,\n\t\tv0: number,\n\t\tt1: number,\n\t\tv1: number,\n\t\tt: number\n\t): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}