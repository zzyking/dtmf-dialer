{"ast":null,"code":"import { TimeClass } from \"../../core/type/Time.js\";\nimport { TimelineValue } from \"../../core/util/TimelineValue.js\";\nimport { Pow } from \"../../signal/Pow.js\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization.js\";\nimport { Gain } from \"../context/Gain.js\";\nimport { ToneWithContext } from \"../context/ToneWithContext.js\";\nimport { TicksClass } from \"../type/Ticks.js\";\nimport { TransportTimeClass } from \"../type/TransportTime.js\";\nimport { enterScheduledCallback } from \"../util/Debug.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Emitter } from \"../util/Emitter.js\";\nimport { readOnly, writable } from \"../util/Interface.js\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isArray, isDefined } from \"../util/TypeCheck.js\";\nimport { Clock } from \"./Clock.js\";\nimport { TransportEvent } from \"./TransportEvent.js\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent.js\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.getTransport().scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.getTransport().start();\n * @category Core\n */\nexport class TransportClass extends ToneWithContext {\n  constructor() {\n    const options = optionsFromArguments(TransportClass.getDefaults(), arguments);\n    super(options);\n    this.name = \"Transport\";\n    //-------------------------------------\n    // \tLOOPING\n    //-------------------------------------\n    /**\n     * If the transport loops or not.\n     */\n    this._loop = new TimelineValue(false);\n    /**\n     * The loop start position in ticks\n     */\n    this._loopStart = 0;\n    /**\n     * The loop end position in ticks\n     */\n    this._loopEnd = 0;\n    //-------------------------------------\n    // \tTIMELINE EVENTS\n    //-------------------------------------\n    /**\n     * All the events in an object to keep track by ID\n     */\n    this._scheduledEvents = {};\n    /**\n     * The scheduled events.\n     */\n    this._timeline = new Timeline();\n    /**\n     * Repeated events\n     */\n    this._repeatedEvents = new IntervalTimeline();\n    /**\n     * All of the synced Signals\n     */\n    this._syncedSignals = [];\n    /**\n     * The swing amount\n     */\n    this._swingAmount = 0;\n    // CLOCK/TEMPO\n    this._ppq = options.ppq;\n    this._clock = new Clock({\n      callback: this._processTick.bind(this),\n      context: this.context,\n      frequency: 0,\n      units: \"bpm\"\n    });\n    this._bindClockEvents();\n    this.bpm = this._clock.frequency;\n    this._clock.frequency.multiplier = options.ppq;\n    this.bpm.setValueAtTime(options.bpm, 0);\n    readOnly(this, \"bpm\");\n    this._timeSignature = options.timeSignature;\n    // SWING\n    this._swingTicks = options.ppq / 2; // 8n\n  }\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      bpm: 120,\n      loopEnd: \"4m\",\n      loopStart: 0,\n      ppq: 192,\n      swing: 0,\n      swingSubdivision: \"8n\",\n      timeSignature: 4\n    });\n  }\n  //-------------------------------------\n  // \tTICKS\n  //-------------------------------------\n  /**\n   * called on every tick\n   * @param  tickTime clock relative tick time\n   */\n  _processTick(tickTime, ticks) {\n    // do the loop test\n    if (this._loop.get(tickTime)) {\n      if (ticks >= this._loopEnd) {\n        this.emit(\"loopEnd\", tickTime);\n        this._clock.setTicksAtTime(this._loopStart, tickTime);\n        ticks = this._loopStart;\n        this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n        this.emit(\"loop\", tickTime);\n      }\n    }\n    // handle swing\n    if (this._swingAmount > 0 && ticks % this._ppq !== 0 &&\n    // not on a downbeat\n    ticks % (this._swingTicks * 2) !== 0) {\n      // add some swing\n      const progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);\n      const amount = Math.sin(progress * Math.PI) * this._swingAmount;\n      tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n    }\n    // invoke the timeline events scheduled on this tick\n    enterScheduledCallback(true);\n    this._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n    enterScheduledCallback(false);\n  }\n  //-------------------------------------\n  // \tSCHEDULABLE EVENTS\n  //-------------------------------------\n  /**\n   * Schedule an event along the timeline.\n   * @param callback The callback to be invoked at the time.\n   * @param time The time to invoke the callback at.\n   * @return The id of the event which can be used for canceling the event.\n   * @example\n   * // schedule an event on the 16th measure\n   * Tone.getTransport().schedule((time) => {\n   * \t// invoked on measure 16\n   * \tconsole.log(\"measure 16!\");\n   * }, \"16:0:0\");\n   */\n  schedule(callback, time) {\n    const event = new TransportEvent(this, {\n      callback,\n      time: new TransportTimeClass(this.context, time).toTicks()\n    });\n    return this._addEvent(event, this._timeline);\n  }\n  /**\n   * Schedule a repeated event along the timeline. The event will fire\n   * at the `interval` starting at the `startTime` and for the specified\n   * `duration`.\n   * @param  callback   The callback to invoke.\n   * @param  interval   The duration between successive callbacks. Must be a positive number.\n   * @param  startTime  When along the timeline the events should start being invoked.\n   * @param  duration How long the event should repeat.\n   * @return  The ID of the scheduled event. Use this to cancel the event.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * // a callback invoked every eighth note after the first measure\n   * Tone.getTransport().scheduleRepeat((time) => {\n   * \tosc.start(time).stop(time + 0.1);\n   * }, \"8n\", \"1m\");\n   */\n  scheduleRepeat(callback, interval, startTime, duration = Infinity) {\n    const event = new TransportRepeatEvent(this, {\n      callback,\n      duration: new TimeClass(this.context, duration).toTicks(),\n      interval: new TimeClass(this.context, interval).toTicks(),\n      time: new TransportTimeClass(this.context, startTime).toTicks()\n    });\n    // kick it off if the Transport is started\n    // @ts-ignore\n    return this._addEvent(event, this._repeatedEvents);\n  }\n  /**\n   * Schedule an event that will be removed after it is invoked.\n   * @param callback The callback to invoke once.\n   * @param time The time the callback should be invoked.\n   * @returns The ID of the scheduled event.\n   */\n  scheduleOnce(callback, time) {\n    const event = new TransportEvent(this, {\n      callback,\n      once: true,\n      time: new TransportTimeClass(this.context, time).toTicks()\n    });\n    return this._addEvent(event, this._timeline);\n  }\n  /**\n   * Clear the passed in event id from the timeline\n   * @param eventId The id of the event.\n   */\n  clear(eventId) {\n    if (this._scheduledEvents.hasOwnProperty(eventId)) {\n      const item = this._scheduledEvents[eventId.toString()];\n      item.timeline.remove(item.event);\n      item.event.dispose();\n      delete this._scheduledEvents[eventId.toString()];\n    }\n    return this;\n  }\n  /**\n   * Add an event to the correct timeline. Keep track of the\n   * timeline it was added to.\n   * @returns the event id which was just added\n   */\n  _addEvent(event, timeline) {\n    this._scheduledEvents[event.id.toString()] = {\n      event,\n      timeline\n    };\n    timeline.add(event);\n    return event.id;\n  }\n  /**\n   * Remove scheduled events from the timeline after\n   * the given time. Repeated events will be removed\n   * if their startTime is after the given time\n   * @param after Clear all events after this time.\n   */\n  cancel(after = 0) {\n    const computedAfter = this.toTicks(after);\n    this._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n    this._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n    return this;\n  }\n  //-------------------------------------\n  // \tSTART/STOP/PAUSE\n  //-------------------------------------\n  /**\n   * Bind start/stop/pause events from the clock and emit them.\n   */\n  _bindClockEvents() {\n    this._clock.on(\"start\", (time, offset) => {\n      offset = new TicksClass(this.context, offset).toSeconds();\n      this.emit(\"start\", time, offset);\n    });\n    this._clock.on(\"stop\", time => {\n      this.emit(\"stop\", time);\n    });\n    this._clock.on(\"pause\", time => {\n      this.emit(\"pause\", time);\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n   */\n  get state() {\n    return this._clock.getStateAtTime(this.now());\n  }\n  /**\n   * Start the transport and all sources synced to the transport.\n   * @param  time The time when the transport should start.\n   * @param  offset The timeline offset to start the transport.\n   * @example\n   * // start the transport in one second starting at beginning of the 5th measure.\n   * Tone.getTransport().start(\"+1\", \"4:0:0\");\n   */\n  start(time, offset) {\n    // start the context\n    this.context.resume();\n    let offsetTicks;\n    if (isDefined(offset)) {\n      offsetTicks = this.toTicks(offset);\n    }\n    // start the clock\n    this._clock.start(time, offsetTicks);\n    return this;\n  }\n  /**\n   * Stop the transport and all sources synced to the transport.\n   * @param time The time when the transport should stop.\n   * @example\n   * Tone.getTransport().stop();\n   */\n  stop(time) {\n    this._clock.stop(time);\n    return this;\n  }\n  /**\n   * Pause the transport and all sources synced to the transport.\n   */\n  pause(time) {\n    this._clock.pause(time);\n    return this;\n  }\n  /**\n   * Toggle the current state of the transport. If it is\n   * started, it will stop it, otherwise it will start the Transport.\n   * @param  time The time of the event\n   */\n  toggle(time) {\n    time = this.toSeconds(time);\n    if (this._clock.getStateAtTime(time) !== \"started\") {\n      this.start(time);\n    } else {\n      this.stop(time);\n    }\n    return this;\n  }\n  //-------------------------------------\n  // \tSETTERS/GETTERS\n  //-------------------------------------\n  /**\n   * The time signature as just the numerator over 4.\n   * For example 4/4 would be just 4 and 6/8 would be 3.\n   * @example\n   * // common time\n   * Tone.getTransport().timeSignature = 4;\n   * // 7/8\n   * Tone.getTransport().timeSignature = [7, 8];\n   * // this will be reduced to a single number\n   * Tone.getTransport().timeSignature; // returns 3.5\n   */\n  get timeSignature() {\n    return this._timeSignature;\n  }\n  set timeSignature(timeSig) {\n    if (isArray(timeSig)) {\n      timeSig = timeSig[0] / timeSig[1] * 4;\n    }\n    this._timeSignature = timeSig;\n  }\n  /**\n   * When the Transport.loop = true, this is the starting position of the loop.\n   */\n  get loopStart() {\n    return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n  }\n  set loopStart(startPosition) {\n    this._loopStart = this.toTicks(startPosition);\n  }\n  /**\n   * When the Transport.loop = true, this is the ending position of the loop.\n   */\n  get loopEnd() {\n    return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n  }\n  set loopEnd(endPosition) {\n    this._loopEnd = this.toTicks(endPosition);\n  }\n  /**\n   * If the transport loops or not.\n   */\n  get loop() {\n    return this._loop.get(this.now());\n  }\n  set loop(loop) {\n    this._loop.set(loop, this.now());\n  }\n  /**\n   * Set the loop start and stop at the same time.\n   * @example\n   * // loop over the first measure\n   * Tone.getTransport().setLoopPoints(0, \"1m\");\n   * Tone.getTransport().loop = true;\n   */\n  setLoopPoints(startPosition, endPosition) {\n    this.loopStart = startPosition;\n    this.loopEnd = endPosition;\n    return this;\n  }\n  /**\n   * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n   */\n  get swing() {\n    return this._swingAmount;\n  }\n  set swing(amount) {\n    // scale the values to a normal range\n    this._swingAmount = amount;\n  }\n  /**\n   * Set the subdivision which the swing will be applied to.\n   * The default value is an 8th note. Value must be less\n   * than a quarter note.\n   */\n  get swingSubdivision() {\n    return new TicksClass(this.context, this._swingTicks).toNotation();\n  }\n  set swingSubdivision(subdivision) {\n    this._swingTicks = this.toTicks(subdivision);\n  }\n  /**\n   * The Transport's position in Bars:Beats:Sixteenths.\n   * Setting the value will jump to that position right away.\n   */\n  get position() {\n    const now = this.now();\n    const ticks = this._clock.getTicksAtTime(now);\n    return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n  }\n  set position(progress) {\n    const ticks = this.toTicks(progress);\n    this.ticks = ticks;\n  }\n  /**\n   * The Transport's position in seconds.\n   * Setting the value will jump to that position right away.\n   */\n  get seconds() {\n    return this._clock.seconds;\n  }\n  set seconds(s) {\n    const now = this.now();\n    const ticks = this._clock.frequency.timeToTicks(s, now);\n    this.ticks = ticks;\n  }\n  /**\n   * The Transport's loop position as a normalized value. Always\n   * returns 0 if the Transport.loop = false.\n   */\n  get progress() {\n    if (this.loop) {\n      const now = this.now();\n      const ticks = this._clock.getTicksAtTime(now);\n      return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The Transport's current tick position.\n   */\n  get ticks() {\n    return this._clock.ticks;\n  }\n  set ticks(t) {\n    if (this._clock.ticks !== t) {\n      const now = this.now();\n      // stop everything synced to the transport\n      if (this.state === \"started\") {\n        const ticks = this._clock.getTicksAtTime(now);\n        // schedule to start on the next tick, #573\n        const remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now);\n        const time = now + remainingTick;\n        this.emit(\"stop\", time);\n        this._clock.setTicksAtTime(t, time);\n        // restart it with the new time\n        this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n      } else {\n        this.emit(\"ticks\", now);\n        this._clock.setTicksAtTime(t, now);\n      }\n    }\n  }\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n  getTicksAtTime(time) {\n    return this._clock.getTicksAtTime(time);\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n  getSecondsAtTime(time) {\n    return this._clock.getSecondsAtTime(time);\n  }\n  /**\n   * Pulses Per Quarter note. This is the smallest resolution\n   * the Transport timing supports. This should be set once\n   * on initialization and not set again. Changing this value\n   * after other objects have been created can cause problems.\n   */\n  get PPQ() {\n    return this._clock.frequency.multiplier;\n  }\n  set PPQ(ppq) {\n    this._clock.frequency.multiplier = ppq;\n  }\n  //-------------------------------------\n  // \tSYNCING\n  //-------------------------------------\n  /**\n   * Returns the time aligned to the next subdivision\n   * of the Transport. If the Transport is not started,\n   * it will return 0.\n   * Note: this will not work precisely during tempo ramps.\n   * @param  subdivision  The subdivision to quantize to\n   * @return  The context time of the next subdivision.\n   * @example\n   * // the transport must be started, otherwise returns 0\n   * Tone.getTransport().start();\n   * Tone.getTransport().nextSubdivision(\"4n\");\n   */\n  nextSubdivision(subdivision) {\n    subdivision = this.toTicks(subdivision);\n    if (this.state !== \"started\") {\n      // if the transport's not started, return 0\n      return 0;\n    } else {\n      const now = this.now();\n      // the remainder of the current ticks and the subdivision\n      const transportPos = this.getTicksAtTime(now);\n      const remainingTicks = subdivision - transportPos % subdivision;\n      return this._clock.nextTickTime(remainingTicks, now);\n    }\n  }\n  /**\n   * Attaches the signal to the tempo control signal so that\n   * any changes in the tempo will change the signal in the same\n   * ratio.\n   *\n   * @param signal\n   * @param ratio Optionally pass in the ratio between the two signals.\n   * \t\t\tOtherwise it will be computed based on their current values.\n   */\n  syncSignal(signal, ratio) {\n    const now = this.now();\n    let source = this.bpm;\n    let sourceValue = 1 / (60 / source.getValueAtTime(now) / this.PPQ);\n    let nodes = [];\n    // If the signal is in the time domain, sync it to the reciprocal of\n    // the tempo instead of the tempo.\n    if (signal.units === \"time\") {\n      // The input to Pow should be in the range [1 / 4096, 1], where\n      // where 4096 is half of the buffer size of Pow's waveshaper.\n      // Pick a scaling factor based on the initial tempo that ensures\n      // that the initial input is in this range, while leaving room for\n      // tempo changes.\n      const scaleFactor = 1 / 64 / sourceValue;\n      const scaleBefore = new Gain(scaleFactor);\n      const reciprocal = new Pow(-1);\n      const scaleAfter = new Gain(scaleFactor);\n      // @ts-ignore\n      source.chain(scaleBefore, reciprocal, scaleAfter);\n      source = scaleAfter;\n      sourceValue = 1 / sourceValue;\n      nodes = [scaleBefore, reciprocal, scaleAfter];\n    }\n    if (!ratio) {\n      // get the sync ratio\n      if (signal.getValueAtTime(now) !== 0) {\n        ratio = signal.getValueAtTime(now) / sourceValue;\n      } else {\n        ratio = 0;\n      }\n    }\n    const ratioSignal = new Gain(ratio);\n    // @ts-ignore\n    source.connect(ratioSignal);\n    // @ts-ignore\n    ratioSignal.connect(signal._param);\n    nodes.push(ratioSignal);\n    this._syncedSignals.push({\n      initial: signal.value,\n      nodes: nodes,\n      signal\n    });\n    signal.value = 0;\n    return this;\n  }\n  /**\n   * Unsyncs a previously synced signal from the transport's control.\n   * @see {@link syncSignal}.\n   */\n  unsyncSignal(signal) {\n    for (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n      const syncedSignal = this._syncedSignals[i];\n      if (syncedSignal.signal === signal) {\n        syncedSignal.nodes.forEach(node => node.dispose());\n        syncedSignal.signal.value = syncedSignal.initial;\n        this._syncedSignals.splice(i, 1);\n      }\n    }\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n  dispose() {\n    super.dispose();\n    this._clock.dispose();\n    writable(this, \"bpm\");\n    this._timeline.dispose();\n    this._repeatedEvents.dispose();\n    return this;\n  }\n}\nEmitter.mixin(TransportClass);\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit(context => {\n  context.transport = new TransportClass({\n    context\n  });\n});\nonContextClose(context => {\n  context.transport.dispose();\n});","map":{"version":3,"names":["TimeClass","TimelineValue","Pow","onContextClose","onContextInit","Gain","ToneWithContext","TicksClass","TransportTimeClass","enterScheduledCallback","optionsFromArguments","Emitter","readOnly","writable","IntervalTimeline","Timeline","isArray","isDefined","Clock","TransportEvent","TransportRepeatEvent","TransportClass","constructor","options","getDefaults","arguments","name","_loop","_loopStart","_loopEnd","_scheduledEvents","_timeline","_repeatedEvents","_syncedSignals","_swingAmount","_ppq","ppq","_clock","callback","_processTick","bind","context","frequency","units","_bindClockEvents","bpm","multiplier","setValueAtTime","_timeSignature","timeSignature","_swingTicks","Object","assign","loopEnd","loopStart","swing","swingSubdivision","tickTime","ticks","get","emit","setTicksAtTime","getSecondsAtTime","progress","amount","Math","sin","PI","toSeconds","forEachAtTime","event","invoke","schedule","time","toTicks","_addEvent","scheduleRepeat","interval","startTime","duration","Infinity","scheduleOnce","once","clear","eventId","hasOwnProperty","item","toString","timeline","remove","dispose","id","add","cancel","after","computedAfter","forEachFrom","on","offset","state","getStateAtTime","now","start","resume","offsetTicks","stop","pause","toggle","timeSig","startPosition","endPosition","loop","set","setLoopPoints","toNotation","subdivision","position","getTicksAtTime","toBarsBeatsSixteenths","seconds","s","timeToTicks","t","remainingTick","getDurationOfTicks","ceil","PPQ","nextSubdivision","transportPos","remainingTicks","nextTickTime","syncSignal","signal","ratio","source","sourceValue","getValueAtTime","nodes","scaleFactor","scaleBefore","reciprocal","scaleAfter","chain","ratioSignal","connect","_param","push","initial","value","unsyncSignal","i","length","syncedSignal","forEach","node","splice","mixin","transport"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/core/clock/Transport.ts"],"sourcesContent":["import { TimeClass } from \"../../core/type/Time.js\";\nimport { PlaybackState } from \"../../core/util/StateTimeline.js\";\nimport { TimelineValue } from \"../../core/util/TimelineValue.js\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode.js\";\nimport { Pow } from \"../../signal/Pow.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport {\n\tonContextClose,\n\tonContextInit,\n} from \"../context/ContextInitialization.js\";\nimport { Gain } from \"../context/Gain.js\";\nimport {\n\tToneWithContext,\n\tToneWithContextOptions,\n} from \"../context/ToneWithContext.js\";\nimport { TicksClass } from \"../type/Ticks.js\";\nimport { TransportTimeClass } from \"../type/TransportTime.js\";\nimport {\n\tBarsBeatsSixteenths,\n\tBPM,\n\tNormalRange,\n\tSeconds,\n\tSubdivision,\n\tTicks,\n\tTime,\n\tTimeSignature,\n\tTransportTime,\n} from \"../type/Units.js\";\nimport { enterScheduledCallback } from \"../util/Debug.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Emitter } from \"../util/Emitter.js\";\nimport { readOnly, writable } from \"../util/Interface.js\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isArray, isDefined } from \"../util/TypeCheck.js\";\nimport { Clock } from \"./Clock.js\";\nimport { TickParam } from \"./TickParam.js\";\nimport { TransportEvent } from \"./TransportEvent.js\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent.js\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames =\n\t| \"start\"\n\t| \"stop\"\n\t| \"pause\"\n\t| \"loop\"\n\t| \"loopEnd\"\n\t| \"loopStart\"\n\t| \"ticks\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tnodes: ToneAudioNode<any>[];\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.getTransport().scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.getTransport().start();\n * @category Core\n */\nexport class TransportClass\n\textends ToneWithContext<TransportOptions>\n\timplements Emitter<TransportEventNames>\n{\n\treadonly name: string = \"Transport\";\n\n\t//-------------------------------------\n\t// \tLOOPING\n\t//-------------------------------------\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tprivate _loop: TimelineValue<boolean> = new TimelineValue(false);\n\n\t/**\n\t * The loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * The loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t//-------------------------------------\n\t// \tCLOCK/TEMPO\n\t//-------------------------------------\n\n\t/**\n\t * Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t * watches the main oscillator for timing ticks\n\t * initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<\"bpm\">;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * Tone.getTransport().bpm.value = 80;\n\t * // start/stop the oscillator every quarter note\n\t * Tone.getTransport().scheduleRepeat(time => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"4n\");\n\t * Tone.getTransport().start();\n\t * // ramp the bpm to 120 over 10 seconds\n\t * Tone.getTransport().bpm.rampTo(120, 10);\n\t */\n\tbpm: TickParam<\"bpm\">;\n\n\t/**\n\t * The time signature, or more accurately the numerator\n\t * of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t//-------------------------------------\n\t// \tTIMELINE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * The scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t * Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t * All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t//-------------------------------------\n\t// \tSWING\n\t//-------------------------------------\n\n\t/**\n\t * The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t * The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tTransportClass.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback: this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency: 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency as unknown as TickParam<\"bpm\">;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.setValueAtTime(options.bpm, 0);\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tTICKS\n\t//-------------------------------------\n\n\t/**\n\t * called on every tick\n\t * @param  tickTime clock relative tick time\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// do the loop test\n\t\tif (this._loop.get(tickTime)) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\n\t\t\t\t\t\"loopStart\",\n\t\t\t\t\ttickTime,\n\t\t\t\t\tthis._clock.getSecondsAtTime(tickTime)\n\t\t\t\t);\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// handle swing\n\t\tif (\n\t\t\tthis._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0\n\t\t) {\n\t\t\t// add some swing\n\t\t\tconst progress =\n\t\t\t\t(ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin(progress * Math.PI) * this._swingAmount;\n\t\t\ttickTime +=\n\t\t\t\tnew TicksClass(\n\t\t\t\t\tthis.context,\n\t\t\t\t\t(this._swingTicks * 2) / 3\n\t\t\t\t).toSeconds() * amount;\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tenterScheduledCallback(true);\n\t\tthis._timeline.forEachAtTime(ticks, (event) => event.invoke(tickTime));\n\t\tenterScheduledCallback(false);\n\t}\n\n\t//-------------------------------------\n\t// \tSCHEDULABLE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * // schedule an event on the 16th measure\n\t * Tone.getTransport().schedule((time) => {\n\t * \t// invoked on measure 16\n\t * \tconsole.log(\"measure 16!\");\n\t * }, \"16:0:0\");\n\t */\n\tschedule(\n\t\tcallback: TransportCallback,\n\t\ttime: TransportTime | TransportTimeClass\n\t): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * // a callback invoked every eighth note after the first measure\n\t * Tone.getTransport().scheduleRepeat((time) => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time | TimeClass,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration: new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime: new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t * Schedule an event that will be removed after it is invoked.\n\t * @param callback The callback to invoke once.\n\t * @param time The time the callback should be invoked.\n\t * @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(\n\t\tcallback: TransportCallback,\n\t\ttime: TransportTime | TransportTimeClass\n\t): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce: true,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(\n\t\tevent: TransportEvent,\n\t\ttimeline: Timeline<TransportEvent>\n\t): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, (event) =>\n\t\t\tthis.clear(event.id)\n\t\t);\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, (event) =>\n\t\t\tthis.clear(event.id)\n\t\t);\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSTART/STOP/PAUSE\n\t//-------------------------------------\n\n\t/**\n\t * Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * // start the transport in one second starting at beginning of the 5th measure.\n\t * Tone.getTransport().start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\t// start the context\n\t\tthis.context.resume();\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * Tone.getTransport().stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSETTERS/GETTERS\n\t//-------------------------------------\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * // common time\n\t * Tone.getTransport().timeSignature = 4;\n\t * // 7/8\n\t * Tone.getTransport().timeSignature = [7, 8];\n\t * // this will be reduced to a single number\n\t * Tone.getTransport().timeSignature; // returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop.get(this.now());\n\t}\n\tset loop(loop) {\n\t\tthis._loop.set(loop, this.now());\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * // loop over the first measure\n\t * Tone.getTransport().setLoopPoints(0, \"1m\");\n\t * Tone.getTransport().loop = true;\n\t */\n\tsetLoopPoints(\n\t\tstartPosition: TransportTime,\n\t\tendPosition: TransportTime\n\t): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t * The Transport's position in Bars:Beats:Sixteenths.\n\t * Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's position in seconds.\n\t * Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's loop position as a normalized value. Always\n\t * returns 0 if the Transport.loop = false.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (\n\t\t\t\t(ticks - this._loopStart) / (this._loopEnd - this._loopStart)\n\t\t\t);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The Transport's current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\t\t// schedule to start on the next tick, #573\n\t\t\t\tconst remainingTick = this._clock.frequency.getDurationOfTicks(\n\t\t\t\t\tMath.ceil(ticks) - ticks,\n\t\t\t\t\tnow\n\t\t\t\t);\n\t\t\t\tconst time = now + remainingTick;\n\t\t\t\tthis.emit(\"stop\", time);\n\t\t\t\tthis._clock.setTicksAtTime(t, time);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n\t\t\t} else {\n\t\t\t\tthis.emit(\"ticks\", now);\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._clock.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Pulses Per Quarter note. This is the smallest resolution\n\t * the Transport timing supports. This should be set once\n\t * on initialization and not set again. Changing this value\n\t * after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t//-------------------------------------\n\t// \tSYNCING\n\t//-------------------------------------\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * // the transport must be started, otherwise returns 0\n\t * Tone.getTransport().start();\n\t * Tone.getTransport().nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - (transportPos % subdivision);\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t * Attaches the signal to the tempo control signal so that\n\t * any changes in the tempo will change the signal in the same\n\t * ratio.\n\t *\n\t * @param signal\n\t * @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tconst now = this.now();\n\t\tlet source: TickParam<\"bpm\"> | ToneAudioNode<any> = this.bpm;\n\t\tlet sourceValue = 1 / (60 / source.getValueAtTime(now) / this.PPQ);\n\t\tlet nodes: ToneAudioNode<any>[] = [];\n\t\t// If the signal is in the time domain, sync it to the reciprocal of\n\t\t// the tempo instead of the tempo.\n\t\tif (signal.units === \"time\") {\n\t\t\t// The input to Pow should be in the range [1 / 4096, 1], where\n\t\t\t// where 4096 is half of the buffer size of Pow's waveshaper.\n\t\t\t// Pick a scaling factor based on the initial tempo that ensures\n\t\t\t// that the initial input is in this range, while leaving room for\n\t\t\t// tempo changes.\n\t\t\tconst scaleFactor = 1 / 64 / sourceValue;\n\t\t\tconst scaleBefore = new Gain(scaleFactor);\n\t\t\tconst reciprocal = new Pow(-1);\n\t\t\tconst scaleAfter = new Gain(scaleFactor);\n\t\t\t// @ts-ignore\n\t\t\tsource.chain(scaleBefore, reciprocal, scaleAfter);\n\t\t\tsource = scaleAfter;\n\t\t\tsourceValue = 1 / sourceValue;\n\t\t\tnodes = [scaleBefore, reciprocal, scaleAfter];\n\t\t}\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tratio = signal.getValueAtTime(now) / sourceValue;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tsource.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tnodes.push(ratioSignal);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial: signal.value,\n\t\t\tnodes: nodes,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsyncs a previously synced signal from the transport's control.\n\t * @see {@link syncSignal}.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.nodes.forEach((node) => node.dispose());\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (\n\t\tevent: TransportEventNames,\n\t\tcallback: (...args: any[]) => void\n\t) => this;\n\tonce!: (\n\t\tevent: TransportEventNames,\n\t\tcallback: (...args: any[]) => void\n\t) => this;\n\toff!: (\n\t\tevent: TransportEventNames,\n\t\tcallback?: ((...args: any[]) => void) | undefined\n\t) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(TransportClass);\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit((context) => {\n\tcontext.transport = new TransportClass({ context });\n});\n\nonContextClose((context) => {\n\tcontext.transport.dispose();\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}