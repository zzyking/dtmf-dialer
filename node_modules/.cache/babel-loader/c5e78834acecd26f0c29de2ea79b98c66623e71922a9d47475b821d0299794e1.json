{"ast":null,"code":"import { ToneWithContext } from \"../context/ToneWithContext.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { readOnly } from \"../util/Interface.js\";\nimport { StateTimeline } from \"../util/StateTimeline.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\nimport { TickSignal } from \"./TickSignal.js\";\nimport { EQ } from \"../util/Math.js\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource extends ToneWithContext {\n  constructor() {\n    const options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    super(options);\n    this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n    this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n    this._tickOffset = new Timeline();\n    /**\n     * Memoized values of getTicksAtTime at events with state other than \"started\"\n     */\n    this._ticksAtTime = new Timeline();\n    /**\n     * Memoized values of getSecondsAtTime at events with state other than \"started\"\n     */\n    this._secondsAtTime = new Timeline();\n    this.frequency = new TickSignal({\n      context: this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\");\n    // set the initial state\n    this._state.setStateAtTime(\"stopped\", 0);\n    // add the first event\n    this.setTicksAtTime(0, 0);\n  }\n  static getDefaults() {\n    return Object.assign({\n      frequency: 1,\n      units: \"hertz\"\n    }, ToneWithContext.getDefaults());\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n  get state() {\n    return this.getStateAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset The number of ticks to start the source at\n   */\n  start(time, offset) {\n    const computedTime = this.toSeconds(time);\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n      if (isDefined(offset)) {\n        this.setTicksAtTime(offset, computedTime);\n      }\n      this._ticksAtTime.cancel(computedTime);\n      this._secondsAtTime.cancel(computedTime);\n    }\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   */\n  stop(time) {\n    const computedTime = this.toSeconds(time);\n    // cancel the previous stop\n    if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n      const event = this._state.get(computedTime);\n      if (event && event.time > 0) {\n        this._tickOffset.cancel(event.time);\n        this._state.cancel(event.time);\n      }\n    }\n    this._state.cancel(computedTime);\n    this._state.setStateAtTime(\"stopped\", computedTime);\n    this.setTicksAtTime(0, computedTime);\n    this._ticksAtTime.cancel(computedTime);\n    this._secondsAtTime.cancel(computedTime);\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n      this._ticksAtTime.cancel(computedTime);\n      this._secondsAtTime.cancel(computedTime);\n    }\n    return this;\n  }\n  /**\n   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n   * @param time When to clear the events after\n   */\n  cancel(time) {\n    time = this.toSeconds(time);\n    this._state.cancel(time);\n    this._tickOffset.cancel(time);\n    this._ticksAtTime.cancel(time);\n    this._secondsAtTime.cancel(time);\n    return this;\n  }\n  /**\n   * Get the elapsed ticks at the given time\n   * @param  time  When to get the tick value\n   * @return The number of ticks\n   */\n  getTicksAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    const stopEvent = this._state.getLastState(\"stopped\", computedTime);\n    // get previously memoized ticks if available\n    const memoizedEvent = this._ticksAtTime.get(computedTime);\n    // this event allows forEachBetween to iterate until the current time\n    const tmpEvent = {\n      state: \"paused\",\n      time: computedTime\n    };\n    this._state.add(tmpEvent);\n    // keep track of the previous offset event\n    let lastState = memoizedEvent ? memoizedEvent : stopEvent;\n    let elapsedTicks = memoizedEvent ? memoizedEvent.ticks : 0;\n    let eventToMemoize = null;\n    // iterate through all the events since the last stop\n    this._state.forEachBetween(lastState.time, computedTime + this.sampleTime, e => {\n      let periodStartTime = lastState.time;\n      // if there is an offset event in this period use that\n      const offsetEvent = this._tickOffset.get(e.time);\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedTicks = offsetEvent.ticks;\n        periodStartTime = offsetEvent.time;\n      }\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n        // do not memoize the temporary event\n        if (e.time !== tmpEvent.time) {\n          eventToMemoize = {\n            state: e.state,\n            time: e.time,\n            ticks: elapsedTicks\n          };\n        }\n      }\n      lastState = e;\n    });\n    // remove the temporary event\n    this._state.remove(tmpEvent);\n    // memoize the ticks at the most recent event with state other than \"started\"\n    if (eventToMemoize) {\n      this._ticksAtTime.add(eventToMemoize);\n    }\n    // return the ticks\n    return elapsedTicks;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked. Returns -1 when stopped.\n   */\n  get ticks() {\n    return this.getTicksAtTime(this.now());\n  }\n  set ticks(t) {\n    this.setTicksAtTime(t, this.now());\n  }\n  /**\n   * The time since ticks=0 that the TickSource has been running. Accounts\n   * for tempo curves\n   */\n  get seconds() {\n    return this.getSecondsAtTime(this.now());\n  }\n  set seconds(s) {\n    const now = this.now();\n    const ticks = this.frequency.timeToTicks(s, now);\n    this.setTicksAtTime(ticks, now);\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n  getSecondsAtTime(time) {\n    time = this.toSeconds(time);\n    const stopEvent = this._state.getLastState(\"stopped\", time);\n    // this event allows forEachBetween to iterate until the current time\n    const tmpEvent = {\n      state: \"paused\",\n      time\n    };\n    this._state.add(tmpEvent);\n    // get previously memoized seconds if available\n    const memoizedEvent = this._secondsAtTime.get(time);\n    // keep track of the previous offset event\n    let lastState = memoizedEvent ? memoizedEvent : stopEvent;\n    let elapsedSeconds = memoizedEvent ? memoizedEvent.seconds : 0;\n    let eventToMemoize = null;\n    // iterate through all the events since the last stop\n    this._state.forEachBetween(lastState.time, time + this.sampleTime, e => {\n      let periodStartTime = lastState.time;\n      // if there is an offset event in this period use that\n      const offsetEvent = this._tickOffset.get(e.time);\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedSeconds = offsetEvent.seconds;\n        periodStartTime = offsetEvent.time;\n      }\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedSeconds += e.time - periodStartTime;\n        // do not memoize the temporary event\n        if (e.time !== tmpEvent.time) {\n          eventToMemoize = {\n            state: e.state,\n            time: e.time,\n            seconds: elapsedSeconds\n          };\n        }\n      }\n      lastState = e;\n    });\n    // remove the temporary event\n    this._state.remove(tmpEvent);\n    // memoize the seconds at the most recent event with state other than \"started\"\n    if (eventToMemoize) {\n      this._secondsAtTime.add(eventToMemoize);\n    }\n    // return the seconds\n    return elapsedSeconds;\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n  setTicksAtTime(ticks, time) {\n    time = this.toSeconds(time);\n    this._tickOffset.cancel(time);\n    this._tickOffset.add({\n      seconds: this.frequency.getDurationOfTicks(ticks, time),\n      ticks,\n      time\n    });\n    this._ticksAtTime.cancel(time);\n    this._secondsAtTime.cancel(time);\n    return this;\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   */\n  getStateAtTime(time) {\n    time = this.toSeconds(time);\n    return this._state.getValueAtTime(time);\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n  getTimeOfTick(tick, before = this.now()) {\n    const offset = this._tickOffset.get(before);\n    const event = this._state.get(before);\n    const startTime = Math.max(offset.time, event.time);\n    const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n    return this.frequency.getTimeOfTick(absoluteTicks);\n  }\n  /**\n   * Invoke the callback event at all scheduled ticks between the\n   * start time and the end time\n   * @param  startTime  The beginning of the search range\n   * @param  endTime    The end of the search range\n   * @param  callback   The callback to invoke with each tick\n   */\n  forEachTickBetween(startTime, endTime, callback) {\n    // only iterate through the sections where it is \"started\"\n    let lastStateEvent = this._state.get(startTime);\n    this._state.forEachBetween(startTime, endTime, event => {\n      if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n      }\n      lastStateEvent = event;\n    });\n    let error = null;\n    if (lastStateEvent && lastStateEvent.state === \"started\") {\n      const maxStartTime = Math.max(lastStateEvent.time, startTime);\n      // figure out the difference between the frequency ticks and the\n      const startTicks = this.frequency.getTicksAtTime(maxStartTime);\n      const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n      const diff = startTicks - ticksAtStart;\n      let offset = Math.ceil(diff) - diff;\n      // guard against floating point issues\n      offset = EQ(offset, 1) ? 0 : offset;\n      let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n      while (nextTickTime < endTime) {\n        try {\n          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n        } catch (e) {\n          error = e;\n          break;\n        }\n        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n      }\n    }\n    if (error) {\n      throw error;\n    }\n    return this;\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this._state.dispose();\n    this._tickOffset.dispose();\n    this._ticksAtTime.dispose();\n    this._secondsAtTime.dispose();\n    this.frequency.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["ToneWithContext","optionsFromArguments","readOnly","StateTimeline","Timeline","isDefined","TickSignal","EQ","TickSource","constructor","options","getDefaults","arguments","name","_state","_tickOffset","_ticksAtTime","_secondsAtTime","frequency","context","units","value","setStateAtTime","setTicksAtTime","Object","assign","state","getStateAtTime","now","start","time","offset","computedTime","toSeconds","getValueAtTime","cancel","stop","event","get","pause","getTicksAtTime","stopEvent","getLastState","memoizedEvent","tmpEvent","add","lastState","elapsedTicks","ticks","eventToMemoize","forEachBetween","sampleTime","e","periodStartTime","offsetEvent","remove","t","seconds","getSecondsAtTime","s","timeToTicks","elapsedSeconds","getDurationOfTicks","getTimeOfTick","tick","before","startTime","Math","max","absoluteTicks","forEachTickBetween","endTime","callback","lastStateEvent","error","maxStartTime","startTicks","ticksAtStart","diff","ceil","nextTickTime","round","dispose"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/core/clock/TickSource.ts"],"sourcesContent":["import {\n\tToneWithContext,\n\tToneWithContextOptions,\n} from \"../context/ToneWithContext.js\";\nimport { Seconds, Ticks, Time } from \"../type/Units.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { readOnly } from \"../util/Interface.js\";\nimport {\n\tPlaybackState,\n\tStateTimeline,\n\tStateTimelineEvent,\n} from \"../util/StateTimeline.js\";\nimport { Timeline, TimelineEvent } from \"../util/Timeline.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\nimport { TickSignal } from \"./TickSignal.js\";\nimport { EQ } from \"../util/Math.js\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tunits: \"bpm\" | \"hertz\";\n}\n\ninterface TickSourceOffsetEvent extends TimelineEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\ninterface TickSourceTicksAtTimeEvent extends TimelineEvent {\n\tstate: PlaybackState;\n\ttime: number;\n\tticks: number;\n}\n\ninterface TickSourceSecondsAtTimeEvent extends TimelineEvent {\n\tstate: PlaybackState;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource<\n\tTypeName extends \"bpm\" | \"hertz\",\n> extends ToneWithContext<TickSourceOptions> {\n\treadonly name: string = \"TickSource\";\n\n\t/**\n\t * The frequency the callback function should be invoked.\n\t */\n\treadonly frequency: TickSignal<TypeName>;\n\n\t/**\n\t * The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\t/**\n\t * Memoized values of getTicksAtTime at events with state other than \"started\"\n\t */\n\tprivate _ticksAtTime: Timeline<TickSourceTicksAtTimeEvent> =\n\t\tnew Timeline<TickSourceTicksAtTimeEvent>();\n\n\t/**\n\t * Memoized values of getSecondsAtTime at events with state other than \"started\"\n\t */\n\tprivate _secondsAtTime: Timeline<TickSourceSecondsAtTimeEvent> =\n\t\tnew Timeline<TickSourceSecondsAtTimeEvent>();\n\n\t/**\n\t * @param frequency The initial frequency that the signal ticks at\n\t */\n\tconstructor(frequency?: number);\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tTickSource.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units as TypeName,\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign(\n\t\t\t{\n\t\t\t\tfrequency: 1,\n\t\t\t\tunits: \"hertz\" as const,\n\t\t\t},\n\t\t\tToneWithContext.getDefaults()\n\t\t);\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t\tthis._ticksAtTime.cancel(computedTime);\n\t\t\tthis._secondsAtTime.cancel(computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\tthis._ticksAtTime.cancel(computedTime);\n\t\tthis._secondsAtTime.cancel(computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._ticksAtTime.cancel(computedTime);\n\t\t\tthis._secondsAtTime.cancel(computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t * @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._ticksAtTime.cancel(time);\n\t\tthis._secondsAtTime.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\n\t\t\t\"stopped\",\n\t\t\tcomputedTime\n\t\t) as StateTimelineEvent;\n\n\t\t// get previously memoized ticks if available\n\t\tconst memoizedEvent = this._ticksAtTime.get(computedTime);\n\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = {\n\t\t\tstate: \"paused\",\n\t\t\ttime: computedTime,\n\t\t};\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = memoizedEvent ? memoizedEvent : stopEvent;\n\t\tlet elapsedTicks = memoizedEvent ? memoizedEvent.ticks : 0;\n\t\tlet eventToMemoize: TickSourceTicksAtTimeEvent | null = null;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(\n\t\t\tlastState.time,\n\t\t\tcomputedTime + this.sampleTime,\n\t\t\t(e) => {\n\t\t\t\tlet periodStartTime = lastState.time;\n\t\t\t\t// if there is an offset event in this period use that\n\t\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t\t}\n\t\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\t\telapsedTicks +=\n\t\t\t\t\t\tthis.frequency.getTicksAtTime(e.time) -\n\t\t\t\t\t\tthis.frequency.getTicksAtTime(periodStartTime);\n\t\t\t\t\t// do not memoize the temporary event\n\t\t\t\t\tif (e.time !== tmpEvent.time) {\n\t\t\t\t\t\teventToMemoize = {\n\t\t\t\t\t\t\tstate: e.state,\n\t\t\t\t\t\t\ttime: e.time,\n\t\t\t\t\t\t\tticks: elapsedTicks,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastState = e;\n\t\t\t}\n\t\t);\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// memoize the ticks at the most recent event with state other than \"started\"\n\t\tif (eventToMemoize) {\n\t\t\tthis._ticksAtTime.add(eventToMemoize);\n\t\t}\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t * The time since ticks=0 that the TickSource has been running. Accounts\n\t * for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\n\t\t\t\"stopped\",\n\t\t\ttime\n\t\t) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// get previously memoized seconds if available\n\t\tconst memoizedEvent = this._secondsAtTime.get(time);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = memoizedEvent ? memoizedEvent : stopEvent;\n\t\tlet elapsedSeconds = memoizedEvent ? memoizedEvent.seconds : 0;\n\t\tlet eventToMemoize: TickSourceSecondsAtTimeEvent | null = null;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(\n\t\t\tlastState.time,\n\t\t\ttime + this.sampleTime,\n\t\t\t(e) => {\n\t\t\t\tlet periodStartTime = lastState.time;\n\t\t\t\t// if there is an offset event in this period use that\n\t\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t\t}\n\t\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t\t\t// do not memoize the temporary event\n\t\t\t\t\tif (e.time !== tmpEvent.time) {\n\t\t\t\t\t\teventToMemoize = {\n\t\t\t\t\t\t\tstate: e.state,\n\t\t\t\t\t\t\ttime: e.time,\n\t\t\t\t\t\t\tseconds: elapsedSeconds,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastState = e;\n\t\t\t}\n\t\t);\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// memoize the seconds at the most recent event with state other than \"started\"\n\t\tif (eventToMemoize) {\n\t\t\tthis._secondsAtTime.add(eventToMemoize);\n\t\t}\n\n\t\t// return the seconds\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds: this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\tthis._ticksAtTime.cancel(time);\n\t\tthis._secondsAtTime.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks =\n\t\t\tthis.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t * Invoke the callback event at all scheduled ticks between the\n\t * start time and the end time\n\t * @param  startTime  The beginning of the search range\n\t * @param  endTime    The end of the search range\n\t * @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(\n\t\tstartTime: number,\n\t\tendTime: number,\n\t\tcallback: (when: Seconds, ticks: Ticks) => void\n\t): this {\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(startTime);\n\t\tthis._state.forEachBetween(startTime, endTime, (event) => {\n\t\t\tif (\n\t\t\t\tlastStateEvent &&\n\t\t\t\tlastStateEvent.state === \"started\" &&\n\t\t\t\tevent.state !== \"started\"\n\t\t\t) {\n\t\t\t\tthis.forEachTickBetween(\n\t\t\t\t\tMath.max(lastStateEvent.time, startTime),\n\t\t\t\t\tevent.time - this.sampleTime,\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error: Error | null = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\") {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, startTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(\n\t\t\t\tlastStateEvent.time\n\t\t\t);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = Math.ceil(diff) - diff;\n\t\t\t// guard against floating point issues\n\t\t\toffset = EQ(offset, 1) ? 0 : offset;\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(\n\t\t\t\tstartTicks + offset\n\t\t\t);\n\t\t\twhile (nextTickTime < endTime) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(\n\t\t\t\t\t\tnextTickTime,\n\t\t\t\t\t\tMath.round(this.getTicksAtTime(nextTickTime))\n\t\t\t\t\t);\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(\n\t\t\t\t\t1,\n\t\t\t\t\tnextTickTime\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis._ticksAtTime.dispose();\n\t\tthis._secondsAtTime.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}