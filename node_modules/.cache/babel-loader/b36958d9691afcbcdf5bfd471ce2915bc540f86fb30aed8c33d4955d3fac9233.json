{"ast":null,"code":"import { MidiClass } from \"../core/type/Midi.js\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck.js\";\nimport { Instrument } from \"./Instrument.js\";\nimport { Monophonic } from \"./Monophonic.js\";\nimport { Synth } from \"./Synth.js\";\nimport { assert, warn } from \"../core/util/Debug.js\";\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second parameter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport class PolySynth extends Instrument {\n  constructor() {\n    const options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n    super(options);\n    this.name = \"PolySynth\";\n    /**\n     * The voices which are not currently in use\n     */\n    this._availableVoices = [];\n    /**\n     * The currently active voices\n     */\n    this._activeVoices = [];\n    /**\n     * All of the allocated voices for this synth.\n     */\n    this._voices = [];\n    /**\n     * The GC timeout. Held so that it could be cancelled when the node is disposed.\n     */\n    this._gcTimeout = -1;\n    /**\n     * A moving average of the number of active voices\n     */\n    this._averageActiveVoices = 0;\n    /**\n     * The release which is scheduled to the timeline.\n     */\n    this._syncedRelease = time => this.releaseAll(time);\n    // check against the old API (pre 14.3.0)\n    assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n    const defaults = options.voice.getDefaults();\n    this.options = Object.assign(defaults, options.options);\n    this.voice = options.voice;\n    this.maxPolyphony = options.maxPolyphony;\n    // create the first voice\n    this._dummyVoice = this._getNextAvailableVoice();\n    // remove it from the voices list\n    const index = this._voices.indexOf(this._dummyVoice);\n    this._voices.splice(index, 1);\n    // kick off the GC interval\n    this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n  }\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      maxPolyphony: 32,\n      options: {},\n      voice: Synth\n    });\n  }\n  /**\n   * The number of active voices.\n   */\n  get activeVoices() {\n    return this._activeVoices.length;\n  }\n  /**\n   * Invoked when the source is done making sound, so that it can be\n   * readded to the pool of available voices\n   */\n  _makeVoiceAvailable(voice) {\n    this._availableVoices.push(voice);\n    // remove the midi note from 'active voices'\n    const activeVoiceIndex = this._activeVoices.findIndex(e => e.voice === voice);\n    this._activeVoices.splice(activeVoiceIndex, 1);\n  }\n  /**\n   * Get an available voice from the pool of available voices.\n   * If one is not available and the maxPolyphony limit is reached,\n   * steal a voice, otherwise return null.\n   */\n  _getNextAvailableVoice() {\n    // if there are available voices, return the first one\n    if (this._availableVoices.length) {\n      return this._availableVoices.shift();\n    } else if (this._voices.length < this.maxPolyphony) {\n      // otherwise if there is still more maxPolyphony, make a new voice\n      const voice = new this.voice(Object.assign(this.options, {\n        context: this.context,\n        onsilence: this._makeVoiceAvailable.bind(this)\n      }));\n      assert(voice instanceof Monophonic, \"Voice must extend Monophonic class\");\n      voice.connect(this.output);\n      this._voices.push(voice);\n      return voice;\n    } else {\n      warn(\"Max polyphony exceeded. Note dropped.\");\n    }\n  }\n  /**\n   * Occasionally check if there are any allocated voices which can be cleaned up.\n   */\n  _collectGarbage() {\n    this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n    if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n      // take off an available note\n      const firstAvail = this._availableVoices.shift();\n      const index = this._voices.indexOf(firstAvail);\n      this._voices.splice(index, 1);\n      if (!this.context.isOffline) {\n        firstAvail.dispose();\n      }\n    }\n  }\n  /**\n   * Internal method which triggers the attack\n   */\n  _triggerAttack(notes, time, velocity) {\n    notes.forEach(note => {\n      const midiNote = new MidiClass(this.context, note).toMidi();\n      const voice = this._getNextAvailableVoice();\n      if (voice) {\n        voice.triggerAttack(note, time, velocity);\n        this._activeVoices.push({\n          midi: midiNote,\n          voice,\n          released: false\n        });\n        this.log(\"triggerAttack\", note, time);\n      }\n    });\n  }\n  /**\n   * Internal method which triggers the release\n   */\n  _triggerRelease(notes, time) {\n    notes.forEach(note => {\n      const midiNote = new MidiClass(this.context, note).toMidi();\n      const event = this._activeVoices.find(({\n        midi,\n        released\n      }) => midi === midiNote && !released);\n      if (event) {\n        // trigger release on that note\n        event.voice.triggerRelease(time);\n        // mark it as released\n        event.released = true;\n        this.log(\"triggerRelease\", note, time);\n      }\n    });\n  }\n  /**\n   * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n   * to wait for just-in-time scheduling\n   */\n  _scheduleEvent(type, notes, time, velocity) {\n    assert(!this.disposed, \"Synth was already disposed\");\n    // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n    if (time <= this.now()) {\n      // do it immediately\n      if (type === \"attack\") {\n        this._triggerAttack(notes, time, velocity);\n      } else {\n        this._triggerRelease(notes, time);\n      }\n    } else {\n      // schedule it to start in the future\n      this.context.setTimeout(() => {\n        if (!this.disposed) {\n          this._scheduleEvent(type, notes, time, velocity);\n        }\n      }, time - this.now());\n    }\n  }\n  /**\n   * Trigger the attack portion of the note\n   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n   * @param  time  The start time of the note.\n   * @param velocity The velocity of the note.\n   * @example\n   * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n   * // trigger a chord immediately with a velocity of 0.2\n   * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n   */\n  triggerAttack(notes, time, velocity) {\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n    const computedTime = this.toSeconds(time);\n    this._scheduleEvent(\"attack\", notes, computedTime, velocity);\n    return this;\n  }\n  /**\n   * Trigger the release of the note. Unlike monophonic instruments,\n   * a note (or array of notes) needs to be passed in as the first argument.\n   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n   * @param  time  When the release will be triggered.\n   * @example\n   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n   * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n   * // trigger the release of the given notes.\n   * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n   * poly.triggerRelease(\"F5\", \"+3\");\n   */\n  triggerRelease(notes, time) {\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n    const computedTime = this.toSeconds(time);\n    this._scheduleEvent(\"release\", notes, computedTime);\n    return this;\n  }\n  /**\n   * Trigger the attack and release after the specified duration\n   * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n   * @param  duration the duration of the note\n   * @param  time  if no time is given, defaults to now\n   * @param  velocity the velocity of the attack (0-1)\n   * @example\n   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n   * // can pass in an array of durations as well\n   * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n   */\n  triggerAttackRelease(notes, duration, time, velocity) {\n    const computedTime = this.toSeconds(time);\n    this.triggerAttack(notes, computedTime, velocity);\n    if (isArray(duration)) {\n      assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n      notes = notes;\n      for (let i = 0; i < notes.length; i++) {\n        const d = duration[Math.min(i, duration.length - 1)];\n        const durationSeconds = this.toSeconds(d);\n        assert(durationSeconds > 0, \"The duration must be greater than 0\");\n        this.triggerRelease(notes[i], computedTime + durationSeconds);\n      }\n    } else {\n      const durationSeconds = this.toSeconds(duration);\n      assert(durationSeconds > 0, \"The duration must be greater than 0\");\n      this.triggerRelease(notes, computedTime + durationSeconds);\n    }\n    return this;\n  }\n  sync() {\n    if (this._syncState()) {\n      this._syncMethod(\"triggerAttack\", 1);\n      this._syncMethod(\"triggerRelease\", 1);\n      // make sure that the sound doesn't play after its been stopped\n      this.context.transport.on(\"stop\", this._syncedRelease);\n      this.context.transport.on(\"pause\", this._syncedRelease);\n      this.context.transport.on(\"loopEnd\", this._syncedRelease);\n    }\n    return this;\n  }\n  /**\n   * Set a member/attribute of the voices\n   * @example\n   * const poly = new Tone.PolySynth().toDestination();\n   * // set all of the voices using an options object for the synth type\n   * poly.set({\n   * \tenvelope: {\n   * \t\tattack: 0.25\n   * \t}\n   * });\n   * poly.triggerAttackRelease(\"Bb3\", 0.2);\n   */\n  set(options) {\n    // remove options which are controlled by the PolySynth\n    const sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]);\n    // store all of the options\n    this.options = deepMerge(this.options, sanitizedOptions);\n    this._voices.forEach(voice => voice.set(sanitizedOptions));\n    this._dummyVoice.set(sanitizedOptions);\n    return this;\n  }\n  get() {\n    return this._dummyVoice.get();\n  }\n  /**\n   * Trigger the release portion of all the currently active voices immediately.\n   * Useful for silencing the synth.\n   */\n  releaseAll(time) {\n    const computedTime = this.toSeconds(time);\n    this._activeVoices.forEach(({\n      voice\n    }) => {\n      voice.triggerRelease(computedTime);\n    });\n    return this;\n  }\n  dispose() {\n    super.dispose();\n    this._dummyVoice.dispose();\n    this._voices.forEach(v => v.dispose());\n    this._activeVoices = [];\n    this._availableVoices = [];\n    this.context.clearInterval(this._gcTimeout);\n    return this;\n  }\n}","map":{"version":3,"names":["MidiClass","deepMerge","omitFromObject","optionsFromArguments","isArray","isNumber","Instrument","Monophonic","Synth","assert","warn","PolySynth","constructor","options","getDefaults","arguments","name","_availableVoices","_activeVoices","_voices","_gcTimeout","_averageActiveVoices","_syncedRelease","time","releaseAll","voice","defaults","Object","assign","maxPolyphony","_dummyVoice","_getNextAvailableVoice","index","indexOf","splice","context","setInterval","_collectGarbage","bind","activeVoices","length","_makeVoiceAvailable","push","activeVoiceIndex","findIndex","e","shift","onsilence","connect","output","Math","max","ceil","firstAvail","isOffline","dispose","_triggerAttack","notes","velocity","forEach","note","midiNote","toMidi","triggerAttack","midi","released","log","_triggerRelease","event","find","triggerRelease","_scheduleEvent","type","disposed","now","setTimeout","Array","computedTime","toSeconds","triggerAttackRelease","duration","i","d","min","durationSeconds","sync","_syncState","_syncMethod","transport","on","set","sanitizedOptions","get","v","clearInterval"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/instrument/PolySynth.ts"],"sourcesContent":["import { MidiClass } from \"../core/type/Midi.js\";\nimport {\n\tFrequency,\n\tMidiNote,\n\tNormalRange,\n\tSeconds,\n\tTime,\n} from \"../core/type/Units.js\";\nimport {\n\tdeepMerge,\n\tomitFromObject,\n\toptionsFromArguments,\n} from \"../core/util/Defaults.js\";\nimport { RecursivePartial } from \"../core/util/Interface.js\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck.js\";\nimport { Instrument, InstrumentOptions } from \"./Instrument.js\";\nimport { MembraneSynth, MembraneSynthOptions } from \"./MembraneSynth.js\";\nimport { FMSynth, FMSynthOptions } from \"./FMSynth.js\";\nimport { AMSynth, AMSynthOptions } from \"./AMSynth.js\";\nimport { MonoSynth, MonoSynthOptions } from \"./MonoSynth.js\";\nimport { MetalSynth, MetalSynthOptions } from \"./MetalSynth.js\";\nimport { Monophonic } from \"./Monophonic.js\";\nimport { Synth, SynthOptions } from \"./Synth.js\";\nimport { assert, warn } from \"../core/util/Debug.js\";\n\ntype VoiceConstructor<V> = {\n\tgetDefaults: () => VoiceOptions<V>;\n} & (new (...args: any[]) => V);\n\ntype OmitMonophonicOptions<T> = Omit<T, \"context\" | \"onsilence\">;\n\ntype VoiceOptions<T> = T extends MembraneSynth\n\t? MembraneSynthOptions\n\t: T extends MetalSynth\n\t\t? MetalSynthOptions\n\t\t: T extends FMSynth\n\t\t\t? FMSynthOptions\n\t\t\t: T extends MonoSynth\n\t\t\t\t? MonoSynthOptions\n\t\t\t\t: T extends AMSynth\n\t\t\t\t\t? AMSynthOptions\n\t\t\t\t\t: T extends Synth\n\t\t\t\t\t\t? SynthOptions\n\t\t\t\t\t\t: T extends Monophonic<infer U>\n\t\t\t\t\t\t\t? U\n\t\t\t\t\t\t\t: never;\n\n/**\n * The settable synth options. excludes monophonic options.\n */\ntype PartialVoiceOptions<T> = RecursivePartial<\n\tOmitMonophonicOptions<VoiceOptions<T>>\n>;\n\nexport interface PolySynthOptions<Voice> extends InstrumentOptions {\n\tmaxPolyphony: number;\n\tvoice: VoiceConstructor<Voice>;\n\toptions: PartialVoiceOptions<Voice>;\n}\n\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second parameter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport class PolySynth<\n\tVoice extends Monophonic<any> = Synth,\n> extends Instrument<VoiceOptions<Voice>> {\n\treadonly name: string = \"PolySynth\";\n\n\t/**\n\t * The voices which are not currently in use\n\t */\n\tprivate _availableVoices: Voice[] = [];\n\n\t/**\n\t * The currently active voices\n\t */\n\tprivate _activeVoices: Array<{\n\t\tmidi: MidiNote;\n\t\tvoice: Voice;\n\t\treleased: boolean;\n\t}> = [];\n\n\t/**\n\t * All of the allocated voices for this synth.\n\t */\n\tprivate _voices: Voice[] = [];\n\n\t/**\n\t * The options that are set on the synth.\n\t */\n\tprivate options: VoiceOptions<Voice>;\n\n\t/**\n\t * The polyphony limit.\n\t */\n\tmaxPolyphony: number;\n\n\t/**\n\t * The voice constructor\n\t */\n\tprivate readonly voice: VoiceConstructor<Voice>;\n\n\t/**\n\t * A voice used for holding the get/set values\n\t */\n\tprivate _dummyVoice: Voice;\n\n\t/**\n\t * The GC timeout. Held so that it could be cancelled when the node is disposed.\n\t */\n\tprivate _gcTimeout = -1;\n\n\t/**\n\t * A moving average of the number of active voices\n\t */\n\tprivate _averageActiveVoices = 0;\n\n\t/**\n\t * @param voice The constructor of the voices\n\t * @param options\tThe options object to set the synth voice\n\t */\n\tconstructor(\n\t\tvoice?: VoiceConstructor<Voice>,\n\t\toptions?: PartialVoiceOptions<Voice>\n\t);\n\tconstructor(options?: Partial<PolySynthOptions<Voice>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tPolySynth.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"voice\", \"options\"]\n\t\t);\n\t\tsuper(options);\n\n\t\t// check against the old API (pre 14.3.0)\n\t\tassert(\n\t\t\t!isNumber(options.voice),\n\t\t\t\"DEPRECATED: The polyphony count is no longer the first argument.\"\n\t\t);\n\n\t\tconst defaults = options.voice.getDefaults();\n\t\tthis.options = Object.assign(\n\t\t\tdefaults,\n\t\t\toptions.options\n\t\t) as VoiceOptions<Voice>;\n\t\tthis.voice = options.voice as unknown as VoiceConstructor<Voice>;\n\t\tthis.maxPolyphony = options.maxPolyphony;\n\n\t\t// create the first voice\n\t\tthis._dummyVoice = this._getNextAvailableVoice() as Voice;\n\t\t// remove it from the voices list\n\t\tconst index = this._voices.indexOf(this._dummyVoice);\n\t\tthis._voices.splice(index, 1);\n\t\t// kick off the GC interval\n\t\tthis._gcTimeout = this.context.setInterval(\n\t\t\tthis._collectGarbage.bind(this),\n\t\t\t1\n\t\t);\n\t}\n\n\tstatic getDefaults(): PolySynthOptions<Synth> {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tmaxPolyphony: 32,\n\t\t\toptions: {},\n\t\t\tvoice: Synth,\n\t\t});\n\t}\n\n\t/**\n\t * The number of active voices.\n\t */\n\tget activeVoices(): number {\n\t\treturn this._activeVoices.length;\n\t}\n\n\t/**\n\t * Invoked when the source is done making sound, so that it can be\n\t * readded to the pool of available voices\n\t */\n\tprivate _makeVoiceAvailable(voice: Voice): void {\n\t\tthis._availableVoices.push(voice);\n\t\t// remove the midi note from 'active voices'\n\t\tconst activeVoiceIndex = this._activeVoices.findIndex(\n\t\t\t(e) => e.voice === voice\n\t\t);\n\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t}\n\n\t/**\n\t * Get an available voice from the pool of available voices.\n\t * If one is not available and the maxPolyphony limit is reached,\n\t * steal a voice, otherwise return null.\n\t */\n\tprivate _getNextAvailableVoice(): Voice | undefined {\n\t\t// if there are available voices, return the first one\n\t\tif (this._availableVoices.length) {\n\t\t\treturn this._availableVoices.shift();\n\t\t} else if (this._voices.length < this.maxPolyphony) {\n\t\t\t// otherwise if there is still more maxPolyphony, make a new voice\n\t\t\tconst voice = new this.voice(\n\t\t\t\tObject.assign(this.options, {\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tonsilence: this._makeVoiceAvailable.bind(this),\n\t\t\t\t})\n\t\t\t);\n\t\t\tassert(\n\t\t\t\tvoice instanceof Monophonic,\n\t\t\t\t\"Voice must extend Monophonic class\"\n\t\t\t);\n\t\t\tvoice.connect(this.output);\n\t\t\tthis._voices.push(voice);\n\t\t\treturn voice;\n\t\t} else {\n\t\t\twarn(\"Max polyphony exceeded. Note dropped.\");\n\t\t}\n\t}\n\n\t/**\n\t * Occasionally check if there are any allocated voices which can be cleaned up.\n\t */\n\tprivate _collectGarbage(): void {\n\t\tthis._averageActiveVoices = Math.max(\n\t\t\tthis._averageActiveVoices * 0.95,\n\t\t\tthis.activeVoices\n\t\t);\n\t\tif (\n\t\t\tthis._availableVoices.length &&\n\t\t\tthis._voices.length > Math.ceil(this._averageActiveVoices + 1)\n\t\t) {\n\t\t\t// take off an available note\n\t\t\tconst firstAvail = this._availableVoices.shift() as Voice;\n\t\t\tconst index = this._voices.indexOf(firstAvail);\n\t\t\tthis._voices.splice(index, 1);\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tfirstAvail.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method which triggers the attack\n\t */\n\tprivate _triggerAttack(\n\t\tnotes: Frequency[],\n\t\ttime: Seconds,\n\t\tvelocity?: NormalRange\n\t): void {\n\t\tnotes.forEach((note) => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst voice = this._getNextAvailableVoice();\n\t\t\tif (voice) {\n\t\t\t\tvoice.triggerAttack(note, time, velocity);\n\t\t\t\tthis._activeVoices.push({\n\t\t\t\t\tmidi: midiNote,\n\t\t\t\t\tvoice,\n\t\t\t\t\treleased: false,\n\t\t\t\t});\n\t\t\t\tthis.log(\"triggerAttack\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Internal method which triggers the release\n\t */\n\tprivate _triggerRelease(notes: Frequency[], time: Seconds): void {\n\t\tnotes.forEach((note) => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst event = this._activeVoices.find(\n\t\t\t\t({ midi, released }) => midi === midiNote && !released\n\t\t\t);\n\t\t\tif (event) {\n\t\t\t\t// trigger release on that note\n\t\t\t\tevent.voice.triggerRelease(time);\n\t\t\t\t// mark it as released\n\t\t\t\tevent.released = true;\n\t\t\t\tthis.log(\"triggerRelease\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n\t * to wait for just-in-time scheduling\n\t */\n\tprivate _scheduleEvent(\n\t\ttype: \"attack\" | \"release\",\n\t\tnotes: Frequency[],\n\t\ttime: Seconds,\n\t\tvelocity?: NormalRange\n\t): void {\n\t\tassert(!this.disposed, \"Synth was already disposed\");\n\t\t// if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\t\tif (time <= this.now()) {\n\t\t\t// do it immediately\n\t\t\tif (type === \"attack\") {\n\t\t\t\tthis._triggerAttack(notes, time, velocity);\n\t\t\t} else {\n\t\t\t\tthis._triggerRelease(notes, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// schedule it to start in the future\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tif (!this.disposed) {\n\t\t\t\t\tthis._scheduleEvent(type, notes, time, velocity);\n\t\t\t\t}\n\t\t\t}, time - this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  The start time of the note.\n\t * @param velocity The velocity of the note.\n\t * @example\n\t * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n\t * // trigger a chord immediately with a velocity of 0.2\n\t * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n\t */\n\ttriggerAttack(\n\t\tnotes: Frequency | Frequency[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange\n\t): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release of the note. Unlike monophonic instruments,\n\t * a note (or array of notes) needs to be passed in as the first argument.\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  When the release will be triggered.\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n\t * // trigger the release of the given notes.\n\t * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n\t * poly.triggerRelease(\"F5\", \"+3\");\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"release\", notes, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and release after the specified duration\n\t * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n\t * @param  duration the duration of the note\n\t * @param  time  if no time is given, defaults to now\n\t * @param  velocity the velocity of the attack (0-1)\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * // can pass in an array of durations as well\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency | Frequency[],\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(\n\t\t\t\tisArray(notes),\n\t\t\t\t\"If the duration is an array, the notes must also be an array\"\n\t\t\t);\n\t\t\tnotes = notes as Frequency[];\n\t\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\t\tconst d = duration[Math.min(i, duration.length - 1)];\n\t\t\t\tconst durationSeconds = this.toSeconds(d);\n\t\t\t\tassert(\n\t\t\t\t\tdurationSeconds > 0,\n\t\t\t\t\t\"The duration must be greater than 0\"\n\t\t\t\t);\n\t\t\t\tthis.triggerRelease(notes[i], computedTime + durationSeconds);\n\t\t\t}\n\t\t} else {\n\t\t\tconst durationSeconds = this.toSeconds(duration);\n\t\t\tassert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\tthis.triggerRelease(notes, computedTime + durationSeconds);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 1);\n\n\t\t\t// make sure that the sound doesn't play after its been stopped\n\t\t\tthis.context.transport.on(\"stop\", this._syncedRelease);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedRelease);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedRelease);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The release which is scheduled to the timeline.\n\t */\n\tprotected _syncedRelease = (time: number) => this.releaseAll(time);\n\n\t/**\n\t * Set a member/attribute of the voices\n\t * @example\n\t * const poly = new Tone.PolySynth().toDestination();\n\t * // set all of the voices using an options object for the synth type\n\t * poly.set({\n\t * \tenvelope: {\n\t * \t\tattack: 0.25\n\t * \t}\n\t * });\n\t * poly.triggerAttackRelease(\"Bb3\", 0.2);\n\t */\n\tset(options: RecursivePartial<VoiceOptions<Voice>>): this {\n\t\t// remove options which are controlled by the PolySynth\n\t\tconst sanitizedOptions = omitFromObject(options, [\n\t\t\t\"onsilence\",\n\t\t\t\"context\",\n\t\t]);\n\t\t// store all of the options\n\t\tthis.options = deepMerge(this.options, sanitizedOptions);\n\t\tthis._voices.forEach((voice) => voice.set(sanitizedOptions));\n\t\tthis._dummyVoice.set(sanitizedOptions);\n\t\treturn this;\n\t}\n\n\tget(): VoiceOptions<Voice> {\n\t\treturn this._dummyVoice.get();\n\t}\n\n\t/**\n\t * Trigger the release portion of all the currently active voices immediately.\n\t * Useful for silencing the synth.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeVoices.forEach(({ voice }) => {\n\t\t\tvoice.triggerRelease(computedTime);\n\t\t});\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dummyVoice.dispose();\n\t\tthis._voices.forEach((v) => v.dispose());\n\t\tthis._activeVoices = [];\n\t\tthis._availableVoices = [];\n\t\tthis.context.clearInterval(this._gcTimeout);\n\t\treturn this;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}