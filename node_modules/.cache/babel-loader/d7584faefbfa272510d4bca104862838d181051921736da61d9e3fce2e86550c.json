{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers.js\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions.js\";\nimport { FrequencyClass } from \"../core/type/Frequency.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck.js\";\nimport { Instrument } from \"../instrument/Instrument.js\";\nimport { ToneBufferSource } from \"../source/buffer/ToneBufferSource.js\";\nimport { timeRange } from \"../core/util/Decorator.js\";\nimport { assert } from \"../core/util/Debug.js\";\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use {@link Player}.\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\nexport class Sampler extends Instrument {\n  constructor() {\n    const options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n    super(options);\n    this.name = \"Sampler\";\n    /**\n     * The object of all currently playing BufferSources\n     */\n    this._activeSources = new Map();\n    const urlMap = {};\n    Object.keys(options.urls).forEach(note => {\n      const noteNumber = parseInt(note, 10);\n      assert(isNote(note) || isNumber(noteNumber) && isFinite(noteNumber), `url key is neither a note or midi pitch: ${note}`);\n      if (isNote(note)) {\n        // convert the note name to MIDI\n        const mid = new FrequencyClass(this.context, note).toMidi();\n        urlMap[mid] = options.urls[note];\n      } else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n        // otherwise if it's numbers assume it's midi\n        urlMap[noteNumber] = options.urls[noteNumber];\n      }\n    });\n    this._buffers = new ToneAudioBuffers({\n      urls: urlMap,\n      onload: options.onload,\n      baseUrl: options.baseUrl,\n      onerror: options.onerror\n    });\n    this.attack = options.attack;\n    this.release = options.release;\n    this.curve = options.curve;\n    // invoke the callback if it's already loaded\n    if (this._buffers.loaded) {\n      // invoke onload deferred\n      Promise.resolve().then(options.onload);\n    }\n  }\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      attack: 0,\n      baseUrl: \"\",\n      curve: \"exponential\",\n      onload: noOp,\n      onerror: noOp,\n      release: 0.1,\n      urls: {}\n    });\n  }\n  /**\n   * Returns the difference in steps between the given midi note at the closets sample.\n   */\n  _findClosest(midi) {\n    // searches within 8 octaves of the given midi note\n    const MAX_INTERVAL = 96;\n    let interval = 0;\n    while (interval < MAX_INTERVAL) {\n      // check above and below\n      if (this._buffers.has(midi + interval)) {\n        return -interval;\n      } else if (this._buffers.has(midi - interval)) {\n        return interval;\n      }\n      interval++;\n    }\n    throw new Error(`No available buffers for note: ${midi}`);\n  }\n  /**\n   * @param  notes\tThe note to play, or an array of notes.\n   * @param  time     When to play the note\n   * @param  velocity The velocity to play the sample back.\n   */\n  triggerAttack(notes, time, velocity = 1) {\n    this.log(\"triggerAttack\", notes, time, velocity);\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n    notes.forEach(note => {\n      const midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());\n      const midi = Math.round(midiFloat);\n      const remainder = midiFloat - midi;\n      // find the closest note pitch\n      const difference = this._findClosest(midi);\n      const closestNote = midi - difference;\n      const buffer = this._buffers.get(closestNote);\n      const playbackRate = intervalToFrequencyRatio(difference + remainder);\n      // play that note\n      const source = new ToneBufferSource({\n        url: buffer,\n        context: this.context,\n        curve: this.curve,\n        fadeIn: this.attack,\n        fadeOut: this.release,\n        playbackRate\n      }).connect(this.output);\n      source.start(time, 0, buffer.duration / playbackRate, velocity);\n      // add it to the active sources\n      if (!isArray(this._activeSources.get(midi))) {\n        this._activeSources.set(midi, []);\n      }\n      this._activeSources.get(midi).push(source);\n      // remove it when it's done\n      source.onended = () => {\n        if (this._activeSources && this._activeSources.has(midi)) {\n          const sources = this._activeSources.get(midi);\n          const index = sources.indexOf(source);\n          if (index !== -1) {\n            sources.splice(index, 1);\n          }\n        }\n      };\n    });\n    return this;\n  }\n  /**\n   * @param  notes\tThe note to release, or an array of notes.\n   * @param  time     \tWhen to release the note.\n   */\n  triggerRelease(notes, time) {\n    this.log(\"triggerRelease\", notes, time);\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n    notes.forEach(note => {\n      const midi = new FrequencyClass(this.context, note).toMidi();\n      // find the note\n      if (this._activeSources.has(midi) && this._activeSources.get(midi).length) {\n        const sources = this._activeSources.get(midi);\n        time = this.toSeconds(time);\n        sources.forEach(source => {\n          source.stop(time);\n        });\n        this._activeSources.set(midi, []);\n      }\n    });\n    return this;\n  }\n  /**\n   * Release all currently active notes.\n   * @param  time     \tWhen to release the notes.\n   */\n  releaseAll(time) {\n    const computedTime = this.toSeconds(time);\n    this._activeSources.forEach(sources => {\n      while (sources.length) {\n        const source = sources.shift();\n        source.stop(computedTime);\n      }\n    });\n    return this;\n  }\n  sync() {\n    if (this._syncState()) {\n      this._syncMethod(\"triggerAttack\", 1);\n      this._syncMethod(\"triggerRelease\", 1);\n    }\n    return this;\n  }\n  /**\n   * Invoke the attack phase, then after the duration, invoke the release.\n   * @param  notes\tThe note to play and release, or an array of notes.\n   * @param  duration The time the note should be held\n   * @param  time     When to start the attack\n   * @param  velocity The velocity of the attack\n   */\n  triggerAttackRelease(notes, duration, time, velocity = 1) {\n    const computedTime = this.toSeconds(time);\n    this.triggerAttack(notes, computedTime, velocity);\n    if (isArray(duration)) {\n      assert(isArray(notes), \"notes must be an array when duration is array\");\n      notes.forEach((note, index) => {\n        const d = duration[Math.min(index, duration.length - 1)];\n        this.triggerRelease(note, computedTime + this.toSeconds(d));\n      });\n    } else {\n      this.triggerRelease(notes, computedTime + this.toSeconds(duration));\n    }\n    return this;\n  }\n  /**\n   * Add a note to the sampler.\n   * @param  note      The buffer's pitch.\n   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n   * @param  callback  The callback to invoke when the url is loaded.\n   */\n  add(note, url, callback) {\n    assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n    if (isNote(note)) {\n      // convert the note name to MIDI\n      const mid = new FrequencyClass(this.context, note).toMidi();\n      this._buffers.add(mid, url, callback);\n    } else {\n      // otherwise if it's numbers assume it's midi\n      this._buffers.add(note, url, callback);\n    }\n    return this;\n  }\n  /**\n   * If the buffers are loaded or not\n   */\n  get loaded() {\n    return this._buffers.loaded;\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this._buffers.dispose();\n    this._activeSources.forEach(sources => {\n      sources.forEach(source => source.dispose());\n    });\n    this._activeSources.clear();\n    return this;\n  }\n}\n__decorate([timeRange(0)], Sampler.prototype, \"attack\", void 0);\n__decorate([timeRange(0)], Sampler.prototype, \"release\", void 0);","map":{"version":3,"names":["ToneAudioBuffers","ftomf","intervalToFrequencyRatio","FrequencyClass","optionsFromArguments","noOp","isArray","isNote","isNumber","Instrument","ToneBufferSource","timeRange","assert","Sampler","constructor","options","getDefaults","arguments","name","_activeSources","Map","urlMap","Object","keys","urls","forEach","note","noteNumber","parseInt","isFinite","mid","context","toMidi","_buffers","onload","baseUrl","onerror","attack","release","curve","loaded","Promise","resolve","then","assign","_findClosest","midi","MAX_INTERVAL","interval","has","Error","triggerAttack","notes","time","velocity","log","Array","midiFloat","toFrequency","Math","round","remainder","difference","closestNote","buffer","get","playbackRate","source","url","fadeIn","fadeOut","connect","output","start","duration","set","push","onended","sources","index","indexOf","splice","triggerRelease","length","toSeconds","stop","releaseAll","computedTime","shift","sync","_syncState","_syncMethod","triggerAttackRelease","d","min","add","callback","dispose","clear","__decorate"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/instrument/Sampler.ts"],"sourcesContent":["import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer.js\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers.js\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions.js\";\nimport { FrequencyClass } from \"../core/type/Frequency.js\";\nimport {\n\tFrequency,\n\tInterval,\n\tMidiNote,\n\tNormalRange,\n\tNote,\n\tTime,\n} from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck.js\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument.js\";\nimport {\n\tToneBufferSource,\n\tToneBufferSourceCurve,\n} from \"../source/buffer/ToneBufferSource.js\";\nimport { timeRange } from \"../core/util/Decorator.js\";\nimport { assert } from \"../core/util/Debug.js\";\n\ninterface SamplesMap {\n\t[note: string]: ToneAudioBuffer | AudioBuffer | string;\n\t[midi: number]: ToneAudioBuffer | AudioBuffer | string;\n}\n\nexport interface SamplerOptions extends InstrumentOptions {\n\tattack: Time;\n\trelease: Time;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tbaseUrl: string;\n\tcurve: ToneBufferSourceCurve;\n\turls: SamplesMap;\n}\n\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use {@link Player}.\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\nexport class Sampler extends Instrument<SamplerOptions> {\n\treadonly name: string = \"Sampler\";\n\n\t/**\n\t * The stored and loaded buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * The object of all currently playing BufferSources\n\t */\n\tprivate _activeSources: Map<MidiNote, ToneBufferSource[]> = new Map();\n\n\t/**\n\t * The envelope applied to the beginning of the sample.\n\t * @min 0\n\t * @max 1\n\t */\n\t@timeRange(0)\n\tattack: Time;\n\n\t/**\n\t * The envelope applied to the end of the envelope.\n\t * @min 0\n\t * @max 1\n\t */\n\t@timeRange(0)\n\trelease: Time;\n\n\t/**\n\t * The shape of the attack/release curve.\n\t * Either \"linear\" or \"exponential\"\n\t */\n\tcurve: ToneBufferSourceCurve;\n\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param onload The callback to invoke when all of the samples are loaded.\n\t * @param baseUrl The root URL of all of the samples, which is prepended to all the URLs.\n\t */\n\tconstructor(samples?: SamplesMap, onload?: () => void, baseUrl?: string);\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param options The remaining options associated with the sampler\n\t */\n\tconstructor(\n\t\tsamples?: SamplesMap,\n\t\toptions?: Partial<Omit<SamplerOptions, \"urls\">>\n\t);\n\tconstructor(options?: Partial<SamplerOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tSampler.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"urls\", \"onload\", \"baseUrl\"],\n\t\t\t\"urls\"\n\t\t);\n\t\tsuper(options);\n\n\t\tconst urlMap = {};\n\t\tObject.keys(options.urls).forEach((note) => {\n\t\t\tconst noteNumber = parseInt(note, 10);\n\t\t\tassert(\n\t\t\t\tisNote(note) || (isNumber(noteNumber) && isFinite(noteNumber)),\n\t\t\t\t`url key is neither a note or midi pitch: ${note}`\n\t\t\t);\n\t\t\tif (isNote(note)) {\n\t\t\t\t// convert the note name to MIDI\n\t\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\t\turlMap[mid] = options.urls[note];\n\t\t\t} else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n\t\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\t\turlMap[noteNumber] = options.urls[noteNumber];\n\t\t\t}\n\t\t});\n\n\t\tthis._buffers = new ToneAudioBuffers({\n\t\t\turls: urlMap,\n\t\t\tonload: options.onload,\n\t\t\tbaseUrl: options.baseUrl,\n\t\t\tonerror: options.onerror,\n\t\t});\n\t\tthis.attack = options.attack;\n\t\tthis.release = options.release;\n\t\tthis.curve = options.curve;\n\n\t\t// invoke the callback if it's already loaded\n\t\tif (this._buffers.loaded) {\n\t\t\t// invoke onload deferred\n\t\t\tPromise.resolve().then(options.onload);\n\t\t}\n\t}\n\n\tstatic getDefaults(): SamplerOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tattack: 0,\n\t\t\tbaseUrl: \"\",\n\t\t\tcurve: \"exponential\" as const,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\trelease: 0.1,\n\t\t\turls: {},\n\t\t});\n\t}\n\n\t/**\n\t * Returns the difference in steps between the given midi note at the closets sample.\n\t */\n\tprivate _findClosest(midi: MidiNote): Interval {\n\t\t// searches within 8 octaves of the given midi note\n\t\tconst MAX_INTERVAL = 96;\n\t\tlet interval = 0;\n\t\twhile (interval < MAX_INTERVAL) {\n\t\t\t// check above and below\n\t\t\tif (this._buffers.has(midi + interval)) {\n\t\t\t\treturn -interval;\n\t\t\t} else if (this._buffers.has(midi - interval)) {\n\t\t\t\treturn interval;\n\t\t\t}\n\t\t\tinterval++;\n\t\t}\n\t\tthrow new Error(`No available buffers for note: ${midi}`);\n\t}\n\n\t/**\n\t * @param  notes\tThe note to play, or an array of notes.\n\t * @param  time     When to play the note\n\t * @param  velocity The velocity to play the sample back.\n\t */\n\ttriggerAttack(\n\t\tnotes: Frequency | Frequency[],\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1\n\t): this {\n\t\tthis.log(\"triggerAttack\", notes, time, velocity);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach((note) => {\n\t\t\tconst midiFloat = ftomf(\n\t\t\t\tnew FrequencyClass(this.context, note).toFrequency()\n\t\t\t);\n\t\t\tconst midi = Math.round(midiFloat) as MidiNote;\n\t\t\tconst remainder = midiFloat - midi;\n\t\t\t// find the closest note pitch\n\t\t\tconst difference = this._findClosest(midi);\n\t\t\tconst closestNote = midi - difference;\n\t\t\tconst buffer = this._buffers.get(closestNote);\n\t\t\tconst playbackRate = intervalToFrequencyRatio(\n\t\t\t\tdifference + remainder\n\t\t\t);\n\t\t\t// play that note\n\t\t\tconst source = new ToneBufferSource({\n\t\t\t\turl: buffer,\n\t\t\t\tcontext: this.context,\n\t\t\t\tcurve: this.curve,\n\t\t\t\tfadeIn: this.attack,\n\t\t\t\tfadeOut: this.release,\n\t\t\t\tplaybackRate,\n\t\t\t}).connect(this.output);\n\t\t\tsource.start(time, 0, buffer.duration / playbackRate, velocity);\n\t\t\t// add it to the active sources\n\t\t\tif (!isArray(this._activeSources.get(midi))) {\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t\t(this._activeSources.get(midi) as ToneBufferSource[]).push(source);\n\n\t\t\t// remove it when it's done\n\t\t\tsource.onended = () => {\n\t\t\t\tif (this._activeSources && this._activeSources.has(midi)) {\n\t\t\t\t\tconst sources = this._activeSources.get(\n\t\t\t\t\t\tmidi\n\t\t\t\t\t) as ToneBufferSource[];\n\t\t\t\t\tconst index = sources.indexOf(source);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tsources.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param  notes\tThe note to release, or an array of notes.\n\t * @param  time     \tWhen to release the note.\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tthis.log(\"triggerRelease\", notes, time);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach((note) => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the note\n\t\t\tif (\n\t\t\t\tthis._activeSources.has(midi) &&\n\t\t\t\t(this._activeSources.get(midi) as ToneBufferSource[]).length\n\t\t\t) {\n\t\t\t\tconst sources = this._activeSources.get(\n\t\t\t\t\tmidi\n\t\t\t\t) as ToneBufferSource[];\n\t\t\t\ttime = this.toSeconds(time);\n\t\t\t\tsources.forEach((source) => {\n\t\t\t\t\tsource.stop(time);\n\t\t\t\t});\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Release all currently active notes.\n\t * @param  time     \tWhen to release the notes.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach((sources) => {\n\t\t\twhile (sources.length) {\n\t\t\t\tconst source = sources.shift() as ToneBufferSource;\n\t\t\t\tsource.stop(computedTime);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the attack phase, then after the duration, invoke the release.\n\t * @param  notes\tThe note to play and release, or an array of notes.\n\t * @param  duration The time the note should be held\n\t * @param  time     When to start the attack\n\t * @param  velocity The velocity of the attack\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency[] | Frequency,\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(\n\t\t\t\tisArray(notes),\n\t\t\t\t\"notes must be an array when duration is array\"\n\t\t\t);\n\t\t\t(notes as Frequency[]).forEach((note, index) => {\n\t\t\t\tconst d = duration[Math.min(index, duration.length - 1)];\n\t\t\t\tthis.triggerRelease(note, computedTime + this.toSeconds(d));\n\t\t\t});\n\t\t} else {\n\t\t\tthis.triggerRelease(notes, computedTime + this.toSeconds(duration));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a note to the sampler.\n\t * @param  note      The buffer's pitch.\n\t * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(\n\t\tnote: Note | MidiNote,\n\t\turl: string | ToneAudioBuffer | AudioBuffer,\n\t\tcallback?: () => void\n\t): this {\n\t\tassert(\n\t\t\tisNote(note) || isFinite(note),\n\t\t\t`note must be a pitch or midi: ${note}`\n\t\t);\n\t\tif (isNote(note)) {\n\t\t\t// convert the note name to MIDI\n\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\tthis._buffers.add(mid, url, callback);\n\t\t} else {\n\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\tthis._buffers.add(note, url, callback);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.dispose();\n\t\tthis._activeSources.forEach((sources) => {\n\t\t\tsources.forEach((source) => source.dispose());\n\t\t});\n\t\tthis._activeSources.clear();\n\t\treturn this;\n\t}\n}\n"],"mappings":";AACA,SAASA,gBAAgB,QAAQ,qCAAqC;AACtE,SAASC,KAAK,EAAEC,wBAAwB,QAAQ,6BAA6B;AAC7E,SAASC,cAAc,QAAQ,2BAA2B;AAS1D,SAASC,oBAAoB,QAAQ,0BAA0B;AAC/D,SAASC,IAAI,QAAQ,2BAA2B;AAChD,SAASC,OAAO,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,2BAA2B;AACrE,SAASC,UAAU,QAA2B,6BAA6B;AAC3E,SACCC,gBAAgB,QAEV,sCAAsC;AAC7C,SAASC,SAAS,QAAQ,2BAA2B;AACrD,SAASC,MAAM,QAAQ,uBAAuB;AAiB9C;;;;;;;;;;;;;;;;;;;;;AAqBA,OAAM,MAAOC,OAAQ,SAAQJ,UAA0B;EAoDtDK,YAAA;IACC,MAAMC,OAAO,GAAGX,oBAAoB,CACnCS,OAAO,CAACG,WAAW,EAAE,EACrBC,SAAS,EACT,CAAC,MAAM,EAAE,QAAQ,EAAE,SAAS,CAAC,EAC7B,MAAM,CACN;IACD,KAAK,CAACF,OAAO,CAAC;IA1DN,KAAAG,IAAI,GAAW,SAAS;IAOjC;;;IAGQ,KAAAC,cAAc,GAAsC,IAAIC,GAAG,EAAE;IAkDpE,MAAMC,MAAM,GAAG,EAAE;IACjBC,MAAM,CAACC,IAAI,CAACR,OAAO,CAACS,IAAI,CAAC,CAACC,OAAO,CAAEC,IAAI,IAAI;MAC1C,MAAMC,UAAU,GAAGC,QAAQ,CAACF,IAAI,EAAE,EAAE,CAAC;MACrCd,MAAM,CACLL,MAAM,CAACmB,IAAI,CAAC,IAAKlB,QAAQ,CAACmB,UAAU,CAAC,IAAIE,QAAQ,CAACF,UAAU,CAAE,EAC9D,4CAA4CD,IAAI,EAAE,CAClD;MACD,IAAInB,MAAM,CAACmB,IAAI,CAAC,EAAE;QACjB;QACA,MAAMI,GAAG,GAAG,IAAI3B,cAAc,CAAC,IAAI,CAAC4B,OAAO,EAAEL,IAAI,CAAC,CAACM,MAAM,EAAE;QAC3DX,MAAM,CAACS,GAAG,CAAC,GAAGf,OAAO,CAACS,IAAI,CAACE,IAAI,CAAC;MACjC,CAAC,MAAM,IAAIlB,QAAQ,CAACmB,UAAU,CAAC,IAAIE,QAAQ,CAACF,UAAU,CAAC,EAAE;QACxD;QACAN,MAAM,CAACM,UAAU,CAAC,GAAGZ,OAAO,CAACS,IAAI,CAACG,UAAU,CAAC;MAC9C;IACD,CAAC,CAAC;IAEF,IAAI,CAACM,QAAQ,GAAG,IAAIjC,gBAAgB,CAAC;MACpCwB,IAAI,EAAEH,MAAM;MACZa,MAAM,EAAEnB,OAAO,CAACmB,MAAM;MACtBC,OAAO,EAAEpB,OAAO,CAACoB,OAAO;MACxBC,OAAO,EAAErB,OAAO,CAACqB;KACjB,CAAC;IACF,IAAI,CAACC,MAAM,GAAGtB,OAAO,CAACsB,MAAM;IAC5B,IAAI,CAACC,OAAO,GAAGvB,OAAO,CAACuB,OAAO;IAC9B,IAAI,CAACC,KAAK,GAAGxB,OAAO,CAACwB,KAAK;IAE1B;IACA,IAAI,IAAI,CAACN,QAAQ,CAACO,MAAM,EAAE;MACzB;MACAC,OAAO,CAACC,OAAO,EAAE,CAACC,IAAI,CAAC5B,OAAO,CAACmB,MAAM,CAAC;IACvC;EACD;EAEA,OAAOlB,WAAWA,CAAA;IACjB,OAAOM,MAAM,CAACsB,MAAM,CAACnC,UAAU,CAACO,WAAW,EAAE,EAAE;MAC9CqB,MAAM,EAAE,CAAC;MACTF,OAAO,EAAE,EAAE;MACXI,KAAK,EAAE,aAAsB;MAC7BL,MAAM,EAAE7B,IAAI;MACZ+B,OAAO,EAAE/B,IAAI;MACbiC,OAAO,EAAE,GAAG;MACZd,IAAI,EAAE;KACN,CAAC;EACH;EAEA;;;EAGQqB,YAAYA,CAACC,IAAc;IAClC;IACA,MAAMC,YAAY,GAAG,EAAE;IACvB,IAAIC,QAAQ,GAAG,CAAC;IAChB,OAAOA,QAAQ,GAAGD,YAAY,EAAE;MAC/B;MACA,IAAI,IAAI,CAACd,QAAQ,CAACgB,GAAG,CAACH,IAAI,GAAGE,QAAQ,CAAC,EAAE;QACvC,OAAO,CAACA,QAAQ;MACjB,CAAC,MAAM,IAAI,IAAI,CAACf,QAAQ,CAACgB,GAAG,CAACH,IAAI,GAAGE,QAAQ,CAAC,EAAE;QAC9C,OAAOA,QAAQ;MAChB;MACAA,QAAQ,EAAE;IACX;IACA,MAAM,IAAIE,KAAK,CAAC,kCAAkCJ,IAAI,EAAE,CAAC;EAC1D;EAEA;;;;;EAKAK,aAAaA,CACZC,KAA8B,EAC9BC,IAAW,EACXC,QAAA,GAAwB,CAAC;IAEzB,IAAI,CAACC,GAAG,CAAC,eAAe,EAAEH,KAAK,EAAEC,IAAI,EAAEC,QAAQ,CAAC;IAChD,IAAI,CAACE,KAAK,CAAClD,OAAO,CAAC8C,KAAK,CAAC,EAAE;MAC1BA,KAAK,GAAG,CAACA,KAAK,CAAC;IAChB;IACAA,KAAK,CAAC3B,OAAO,CAAEC,IAAI,IAAI;MACtB,MAAM+B,SAAS,GAAGxD,KAAK,CACtB,IAAIE,cAAc,CAAC,IAAI,CAAC4B,OAAO,EAAEL,IAAI,CAAC,CAACgC,WAAW,EAAE,CACpD;MACD,MAAMZ,IAAI,GAAGa,IAAI,CAACC,KAAK,CAACH,SAAS,CAAa;MAC9C,MAAMI,SAAS,GAAGJ,SAAS,GAAGX,IAAI;MAClC;MACA,MAAMgB,UAAU,GAAG,IAAI,CAACjB,YAAY,CAACC,IAAI,CAAC;MAC1C,MAAMiB,WAAW,GAAGjB,IAAI,GAAGgB,UAAU;MACrC,MAAME,MAAM,GAAG,IAAI,CAAC/B,QAAQ,CAACgC,GAAG,CAACF,WAAW,CAAC;MAC7C,MAAMG,YAAY,GAAGhE,wBAAwB,CAC5C4D,UAAU,GAAGD,SAAS,CACtB;MACD;MACA,MAAMM,MAAM,GAAG,IAAIzD,gBAAgB,CAAC;QACnC0D,GAAG,EAAEJ,MAAM;QACXjC,OAAO,EAAE,IAAI,CAACA,OAAO;QACrBQ,KAAK,EAAE,IAAI,CAACA,KAAK;QACjB8B,MAAM,EAAE,IAAI,CAAChC,MAAM;QACnBiC,OAAO,EAAE,IAAI,CAAChC,OAAO;QACrB4B;OACA,CAAC,CAACK,OAAO,CAAC,IAAI,CAACC,MAAM,CAAC;MACvBL,MAAM,CAACM,KAAK,CAACpB,IAAI,EAAE,CAAC,EAAEW,MAAM,CAACU,QAAQ,GAAGR,YAAY,EAAEZ,QAAQ,CAAC;MAC/D;MACA,IAAI,CAAChD,OAAO,CAAC,IAAI,CAACa,cAAc,CAAC8C,GAAG,CAACnB,IAAI,CAAC,CAAC,EAAE;QAC5C,IAAI,CAAC3B,cAAc,CAACwD,GAAG,CAAC7B,IAAI,EAAE,EAAE,CAAC;MAClC;MACC,IAAI,CAAC3B,cAAc,CAAC8C,GAAG,CAACnB,IAAI,CAAwB,CAAC8B,IAAI,CAACT,MAAM,CAAC;MAElE;MACAA,MAAM,CAACU,OAAO,GAAG,MAAK;QACrB,IAAI,IAAI,CAAC1D,cAAc,IAAI,IAAI,CAACA,cAAc,CAAC8B,GAAG,CAACH,IAAI,CAAC,EAAE;UACzD,MAAMgC,OAAO,GAAG,IAAI,CAAC3D,cAAc,CAAC8C,GAAG,CACtCnB,IAAI,CACkB;UACvB,MAAMiC,KAAK,GAAGD,OAAO,CAACE,OAAO,CAACb,MAAM,CAAC;UACrC,IAAIY,KAAK,KAAK,CAAC,CAAC,EAAE;YACjBD,OAAO,CAACG,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;UACzB;QACD;MACD,CAAC;IACF,CAAC,CAAC;IACF,OAAO,IAAI;EACZ;EAEA;;;;EAIAG,cAAcA,CAAC9B,KAA8B,EAAEC,IAAW;IACzD,IAAI,CAACE,GAAG,CAAC,gBAAgB,EAAEH,KAAK,EAAEC,IAAI,CAAC;IACvC,IAAI,CAACG,KAAK,CAAClD,OAAO,CAAC8C,KAAK,CAAC,EAAE;MAC1BA,KAAK,GAAG,CAACA,KAAK,CAAC;IAChB;IACAA,KAAK,CAAC3B,OAAO,CAAEC,IAAI,IAAI;MACtB,MAAMoB,IAAI,GAAG,IAAI3C,cAAc,CAAC,IAAI,CAAC4B,OAAO,EAAEL,IAAI,CAAC,CAACM,MAAM,EAAE;MAC5D;MACA,IACC,IAAI,CAACb,cAAc,CAAC8B,GAAG,CAACH,IAAI,CAAC,IAC5B,IAAI,CAAC3B,cAAc,CAAC8C,GAAG,CAACnB,IAAI,CAAwB,CAACqC,MAAM,EAC3D;QACD,MAAML,OAAO,GAAG,IAAI,CAAC3D,cAAc,CAAC8C,GAAG,CACtCnB,IAAI,CACkB;QACvBO,IAAI,GAAG,IAAI,CAAC+B,SAAS,CAAC/B,IAAI,CAAC;QAC3ByB,OAAO,CAACrD,OAAO,CAAE0C,MAAM,IAAI;UAC1BA,MAAM,CAACkB,IAAI,CAAChC,IAAI,CAAC;QAClB,CAAC,CAAC;QACF,IAAI,CAAClC,cAAc,CAACwD,GAAG,CAAC7B,IAAI,EAAE,EAAE,CAAC;MAClC;IACD,CAAC,CAAC;IACF,OAAO,IAAI;EACZ;EAEA;;;;EAIAwC,UAAUA,CAACjC,IAAW;IACrB,MAAMkC,YAAY,GAAG,IAAI,CAACH,SAAS,CAAC/B,IAAI,CAAC;IACzC,IAAI,CAAClC,cAAc,CAACM,OAAO,CAAEqD,OAAO,IAAI;MACvC,OAAOA,OAAO,CAACK,MAAM,EAAE;QACtB,MAAMhB,MAAM,GAAGW,OAAO,CAACU,KAAK,EAAsB;QAClDrB,MAAM,CAACkB,IAAI,CAACE,YAAY,CAAC;MAC1B;IACD,CAAC,CAAC;IACF,OAAO,IAAI;EACZ;EAEAE,IAAIA,CAAA;IACH,IAAI,IAAI,CAACC,UAAU,EAAE,EAAE;MACtB,IAAI,CAACC,WAAW,CAAC,eAAe,EAAE,CAAC,CAAC;MACpC,IAAI,CAACA,WAAW,CAAC,gBAAgB,EAAE,CAAC,CAAC;IACtC;IACA,OAAO,IAAI;EACZ;EAEA;;;;;;;EAOAC,oBAAoBA,CACnBxC,KAA8B,EAC9BsB,QAAuB,EACvBrB,IAAW,EACXC,QAAA,GAAwB,CAAC;IAEzB,MAAMiC,YAAY,GAAG,IAAI,CAACH,SAAS,CAAC/B,IAAI,CAAC;IACzC,IAAI,CAACF,aAAa,CAACC,KAAK,EAAEmC,YAAY,EAAEjC,QAAQ,CAAC;IACjD,IAAIhD,OAAO,CAACoE,QAAQ,CAAC,EAAE;MACtB9D,MAAM,CACLN,OAAO,CAAC8C,KAAK,CAAC,EACd,+CAA+C,CAC/C;MACAA,KAAqB,CAAC3B,OAAO,CAAC,CAACC,IAAI,EAAEqD,KAAK,KAAI;QAC9C,MAAMc,CAAC,GAAGnB,QAAQ,CAACf,IAAI,CAACmC,GAAG,CAACf,KAAK,EAAEL,QAAQ,CAACS,MAAM,GAAG,CAAC,CAAC,CAAC;QACxD,IAAI,CAACD,cAAc,CAACxD,IAAI,EAAE6D,YAAY,GAAG,IAAI,CAACH,SAAS,CAACS,CAAC,CAAC,CAAC;MAC5D,CAAC,CAAC;IACH,CAAC,MAAM;MACN,IAAI,CAACX,cAAc,CAAC9B,KAAK,EAAEmC,YAAY,GAAG,IAAI,CAACH,SAAS,CAACV,QAAQ,CAAC,CAAC;IACpE;IACA,OAAO,IAAI;EACZ;EAEA;;;;;;EAMAqB,GAAGA,CACFrE,IAAqB,EACrB0C,GAA2C,EAC3C4B,QAAqB;IAErBpF,MAAM,CACLL,MAAM,CAACmB,IAAI,CAAC,IAAIG,QAAQ,CAACH,IAAI,CAAC,EAC9B,iCAAiCA,IAAI,EAAE,CACvC;IACD,IAAInB,MAAM,CAACmB,IAAI,CAAC,EAAE;MACjB;MACA,MAAMI,GAAG,GAAG,IAAI3B,cAAc,CAAC,IAAI,CAAC4B,OAAO,EAAEL,IAAI,CAAC,CAACM,MAAM,EAAE;MAC3D,IAAI,CAACC,QAAQ,CAAC8D,GAAG,CAACjE,GAAG,EAAEsC,GAAG,EAAE4B,QAAQ,CAAC;IACtC,CAAC,MAAM;MACN;MACA,IAAI,CAAC/D,QAAQ,CAAC8D,GAAG,CAACrE,IAAI,EAAE0C,GAAG,EAAE4B,QAAQ,CAAC;IACvC;IACA,OAAO,IAAI;EACZ;EAEA;;;EAGA,IAAIxD,MAAMA,CAAA;IACT,OAAO,IAAI,CAACP,QAAQ,CAACO,MAAM;EAC5B;EAEA;;;EAGAyD,OAAOA,CAAA;IACN,KAAK,CAACA,OAAO,EAAE;IACf,IAAI,CAAChE,QAAQ,CAACgE,OAAO,EAAE;IACvB,IAAI,CAAC9E,cAAc,CAACM,OAAO,CAAEqD,OAAO,IAAI;MACvCA,OAAO,CAACrD,OAAO,CAAE0C,MAAM,IAAKA,MAAM,CAAC8B,OAAO,EAAE,CAAC;IAC9C,CAAC,CAAC;IACF,IAAI,CAAC9E,cAAc,CAAC+E,KAAK,EAAE;IAC3B,OAAO,IAAI;EACZ;;AApSAC,UAAA,EADCxF,SAAS,CAAC,CAAC,CAAC,C,sCACA;AAQbwF,UAAA,EADCxF,SAAS,CAAC,CAAC,CAAC,C,uCACC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}