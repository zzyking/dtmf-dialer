{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { Merge } from \"../component/channel/Merge.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Noise } from \"../source/Noise.js\";\nimport { Effect } from \"./Effect.js\";\nimport { OfflineContext } from \"../core/context/OfflineContext.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { assertRange } from \"../core/util/Debug.js\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until {@link ready} resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\nexport class Reverb extends Effect {\n  constructor() {\n    const options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n    super(options);\n    this.name = \"Reverb\";\n    /**\n     * Convolver node\n     */\n    this._convolver = this.context.createConvolver();\n    /**\n     * Resolves when the reverb buffer is generated. Whenever either {@link decay}\n     * or {@link preDelay} are set, you have to wait until {@link ready} resolves\n     * before the IR is generated with the latest values.\n     */\n    this.ready = Promise.resolve();\n    this._decay = options.decay;\n    this._preDelay = options.preDelay;\n    this.generate();\n    this.connectEffect(this._convolver);\n  }\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      decay: 1.5,\n      preDelay: 0.01\n    });\n  }\n  /**\n   * The duration of the reverb.\n   */\n  get decay() {\n    return this._decay;\n  }\n  set decay(time) {\n    time = this.toSeconds(time);\n    assertRange(time, 0.001);\n    this._decay = time;\n    this.generate();\n  }\n  /**\n   * The amount of time before the reverb is fully ramped in.\n   */\n  get preDelay() {\n    return this._preDelay;\n  }\n  set preDelay(time) {\n    time = this.toSeconds(time);\n    assertRange(time, 0);\n    this._preDelay = time;\n    this.generate();\n  }\n  /**\n   * Generate the Impulse Response. Returns a promise while the IR is being generated.\n   * @return Promise which returns this object.\n   */\n  generate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const previousReady = this.ready;\n      // create a noise burst which decays over the duration in each channel\n      const context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n      const noiseL = new Noise({\n        context\n      });\n      const noiseR = new Noise({\n        context\n      });\n      const merge = new Merge({\n        context\n      });\n      noiseL.connect(merge, 0, 0);\n      noiseR.connect(merge, 0, 1);\n      const gainNode = new Gain({\n        context\n      }).toDestination();\n      merge.connect(gainNode);\n      noiseL.start(0);\n      noiseR.start(0);\n      // predelay\n      gainNode.gain.setValueAtTime(0, 0);\n      gainNode.gain.setValueAtTime(1, this._preDelay);\n      // decay\n      gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);\n      // render the buffer\n      const renderPromise = context.render();\n      this.ready = renderPromise.then(noOp);\n      // wait for the previous `ready` to resolve\n      yield previousReady;\n      // set the buffer\n      this._convolver.buffer = (yield renderPromise).get();\n      return this;\n    });\n  }\n  dispose() {\n    super.dispose();\n    this._convolver.disconnect();\n    return this;\n  }\n}","map":{"version":3,"names":["Merge","Gain","optionsFromArguments","Noise","Effect","OfflineContext","noOp","assertRange","Reverb","constructor","options","getDefaults","arguments","name","_convolver","context","createConvolver","ready","Promise","resolve","_decay","decay","_preDelay","preDelay","generate","connectEffect","Object","assign","time","toSeconds","previousReady","sampleRate","noiseL","noiseR","merge","connect","gainNode","toDestination","start","gain","setValueAtTime","exponentialApproachValueAtTime","renderPromise","render","then","buffer","get","dispose","disconnect"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/effect/Reverb.ts"],"sourcesContent":["import { Merge } from \"../component/channel/Merge.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport { Seconds, Time } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Noise } from \"../source/Noise.js\";\nimport { Effect, EffectOptions } from \"./Effect.js\";\nimport { OfflineContext } from \"../core/context/OfflineContext.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { assertRange } from \"../core/util/Debug.js\";\n\ninterface ReverbOptions extends EffectOptions {\n\tdecay: Seconds;\n\tpreDelay: Seconds;\n}\n\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until {@link ready} resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\nexport class Reverb extends Effect<ReverbOptions> {\n\treadonly name: string = \"Reverb\";\n\n\t/**\n\t * Convolver node\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tprivate _decay: Seconds;\n\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tprivate _preDelay: Seconds;\n\n\t/**\n\t * Resolves when the reverb buffer is generated. Whenever either {@link decay}\n\t * or {@link preDelay} are set, you have to wait until {@link ready} resolves\n\t * before the IR is generated with the latest values.\n\t */\n\tready: Promise<void> = Promise.resolve();\n\n\t/**\n\t * @param decay The amount of time it will reverberate for.\n\t */\n\tconstructor(decay?: Seconds);\n\tconstructor(options?: Partial<ReverbOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Reverb.getDefaults(), arguments, [\n\t\t\t\"decay\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._decay = options.decay;\n\t\tthis._preDelay = options.preDelay;\n\t\tthis.generate();\n\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ReverbOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdecay: 1.5,\n\t\t\tpreDelay: 0.01,\n\t\t});\n\t}\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tget decay(): Time {\n\t\treturn this._decay;\n\t}\n\tset decay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0.001);\n\t\tthis._decay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tget preDelay(): Time {\n\t\treturn this._preDelay;\n\t}\n\tset preDelay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0);\n\t\tthis._preDelay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * Generate the Impulse Response. Returns a promise while the IR is being generated.\n\t * @return Promise which returns this object.\n\t */\n\tasync generate(): Promise<this> {\n\t\tconst previousReady = this.ready;\n\n\t\t// create a noise burst which decays over the duration in each channel\n\t\tconst context = new OfflineContext(\n\t\t\t2,\n\t\t\tthis._decay + this._preDelay,\n\t\t\tthis.context.sampleRate\n\t\t);\n\t\tconst noiseL = new Noise({ context });\n\t\tconst noiseR = new Noise({ context });\n\t\tconst merge = new Merge({ context });\n\t\tnoiseL.connect(merge, 0, 0);\n\t\tnoiseR.connect(merge, 0, 1);\n\t\tconst gainNode = new Gain({ context }).toDestination();\n\t\tmerge.connect(gainNode);\n\t\tnoiseL.start(0);\n\t\tnoiseR.start(0);\n\t\t// predelay\n\t\tgainNode.gain.setValueAtTime(0, 0);\n\t\tgainNode.gain.setValueAtTime(1, this._preDelay);\n\t\t// decay\n\t\tgainNode.gain.exponentialApproachValueAtTime(\n\t\t\t0,\n\t\t\tthis._preDelay,\n\t\t\tthis.decay\n\t\t);\n\n\t\t// render the buffer\n\t\tconst renderPromise = context.render();\n\t\tthis.ready = renderPromise.then(noOp);\n\n\t\t// wait for the previous `ready` to resolve\n\t\tawait previousReady;\n\t\t// set the buffer\n\t\tthis._convolver.buffer = (await renderPromise).get() as AudioBuffer;\n\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}