{"ast":null,"code":"import { TicksClass } from \"../type/Ticks.js\";\nimport { TransportEvent } from \"./TransportEvent.js\";\nimport { GT, LT } from \"../util/Math.js\";\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n  /**\n   * @param transport The transport object which the event belongs to\n   */\n  constructor(transport, opts) {\n    super(transport, opts);\n    /**\n     * The ID of the current timeline event\n     */\n    this._currentId = -1;\n    /**\n     * The ID of the next timeline event\n     */\n    this._nextId = -1;\n    /**\n     * The time of the next event\n     */\n    this._nextTick = this.time;\n    /**\n     * a reference to the bound start method\n     */\n    this._boundRestart = this._restart.bind(this);\n    const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n    this.duration = options.duration;\n    this._interval = options.interval;\n    this._nextTick = options.time;\n    this.transport.on(\"start\", this._boundRestart);\n    this.transport.on(\"loopStart\", this._boundRestart);\n    this.transport.on(\"ticks\", this._boundRestart);\n    this.context = this.transport.context;\n    this._restart();\n  }\n  static getDefaults() {\n    return Object.assign({}, TransportEvent.getDefaults(), {\n      duration: Infinity,\n      interval: 1,\n      once: false\n    });\n  }\n  /**\n   * Invoke the callback. Returns the tick time which\n   * the next event should be scheduled at.\n   * @param  time  The AudioContext time in seconds of the event\n   */\n  invoke(time) {\n    // create more events if necessary\n    this._createEvents(time);\n    // call the super class\n    super.invoke(time);\n  }\n  /**\n   * Create an event on the transport on the nextTick\n   */\n  _createEvent() {\n    if (LT(this._nextTick, this.floatTime + this.duration)) {\n      return this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    }\n    return -1;\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n  _createEvents(time) {\n    // schedule the next event\n    // const ticks = this.transport.getTicksAtTime(time);\n    // if the next tick is within the bounds set by \"duration\"\n    if (LT(this._nextTick + this._interval, this.floatTime + this.duration)) {\n      this._nextTick += this._interval;\n      this._currentId = this._nextId;\n      this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    }\n  }\n  /**\n   * Re-compute the events when the transport time has changed from a start/ticks/loopStart event\n   */\n  _restart(time) {\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    // start at the first event\n    this._nextTick = this.floatTime;\n    const ticks = this.transport.getTicksAtTime(time);\n    if (GT(ticks, this.time)) {\n      // the event is not being scheduled from the beginning and should be offset\n      this._nextTick = this.floatTime + Math.ceil((ticks - this.floatTime) / this._interval) * this._interval;\n    }\n    this._currentId = this._createEvent();\n    this._nextTick += this._interval;\n    this._nextId = this._createEvent();\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    super.dispose();\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this.transport.off(\"start\", this._boundRestart);\n    this.transport.off(\"loopStart\", this._boundRestart);\n    this.transport.off(\"ticks\", this._boundRestart);\n    return this;\n  }\n}","map":{"version":3,"names":["TicksClass","TransportEvent","GT","LT","TransportRepeatEvent","constructor","transport","opts","_currentId","_nextId","_nextTick","time","_boundRestart","_restart","bind","options","Object","assign","getDefaults","duration","_interval","interval","on","context","Infinity","once","invoke","_createEvents","_createEvent","floatTime","scheduleOnce","toSeconds","clear","ticks","getTicksAtTime","Math","ceil","dispose","off"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/core/clock/TransportRepeatEvent.ts"],"sourcesContent":["import { BaseContext } from \"../context/BaseContext.js\";\nimport { TicksClass } from \"../type/Ticks.js\";\nimport { Seconds, Ticks, Time } from \"../type/Units.js\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent.js\";\nimport { GT, LT } from \"../util/Math.js\";\nimport type { TransportClass as Transport } from \"./Transport.js\";\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: BaseContext;\n\n\t/**\n\t * @param transport The transport object which the event belongs to\n\t */\n\tconstructor(\n\t\ttransport: Transport,\n\t\topts: Partial<TransportRepeatEventOptions>\n\t) {\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration = options.duration;\n\t\tthis._interval = options.interval;\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.transport.on(\"ticks\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Create an event on the transport on the nextTick\n\t */\n\tprivate _createEvent(): number {\n\t\tif (LT(this._nextTick, this.floatTime + this.duration)) {\n\t\t\treturn this.transport.scheduleOnce(\n\t\t\t\tthis.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds()\n\t\t\t);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\t// const ticks = this.transport.getTicksAtTime(time);\n\t\t// if the next tick is within the bounds set by \"duration\"\n\t\tif (\n\t\t\tLT(this._nextTick + this._interval, this.floatTime + this.duration)\n\t\t) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(\n\t\t\t\tthis.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds()\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Re-compute the events when the transport time has changed from a start/ticks/loopStart event\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\t// start at the first event\n\t\tthis._nextTick = this.floatTime;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (GT(ticks, this.time)) {\n\t\t\t// the event is not being scheduled from the beginning and should be offset\n\t\t\tthis._nextTick =\n\t\t\t\tthis.floatTime +\n\t\t\t\tMath.ceil((ticks - this.floatTime) / this._interval) *\n\t\t\t\t\tthis._interval;\n\t\t}\n\t\tthis._currentId = this._createEvent();\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this._createEvent();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\tthis.transport.off(\"ticks\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}