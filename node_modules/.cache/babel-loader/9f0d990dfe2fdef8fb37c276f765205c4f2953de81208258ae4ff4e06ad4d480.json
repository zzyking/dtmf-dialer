{"ast":null,"code":"import { ToneAudioNode } from \"../../core/context/ToneAudioNode.js\";\nimport { dbToGain } from \"../../core/type/Conversions.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { MeterBase } from \"./MeterBase.js\";\nimport { assert } from \"../../core/util/Debug.js\";\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * Read more about FFT algorithms on [Wikipedia] (https://en.wikipedia.org/wiki/Fast_Fourier_transform).\n * @category Component\n */\nexport class FFT extends MeterBase {\n  constructor() {\n    const options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n    super(options);\n    this.name = \"FFT\";\n    this.normalRange = options.normalRange;\n    this._analyser.type = \"fft\";\n    this.size = options.size;\n  }\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      normalRange: false,\n      size: 1024,\n      smoothing: 0.8\n    });\n  }\n  /**\n   * Gets the current frequency data from the connected audio source.\n   * Returns the frequency data of length {@link size} as a Float32Array of decibel values.\n   */\n  getValue() {\n    const values = this._analyser.getValue();\n    return values.map(v => this.normalRange ? dbToGain(v) : v);\n  }\n  /**\n   * The size of analysis. This must be a power of two in the range 16 to 16384.\n   * Determines the size of the array returned by {@link getValue} (i.e. the number of\n   * frequency bins). Large FFT sizes may be costly to compute.\n   */\n  get size() {\n    return this._analyser.size;\n  }\n  set size(size) {\n    this._analyser.size = size;\n  }\n  /**\n   * 0 represents no time averaging with the last analysis frame.\n   */\n  get smoothing() {\n    return this._analyser.smoothing;\n  }\n  set smoothing(val) {\n    this._analyser.smoothing = val;\n  }\n  /**\n   * Returns the frequency value in hertz of each of the indices of the FFT's {@link getValue} response.\n   * @example\n   * const fft = new Tone.FFT(32);\n   * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));\n   */\n  getFrequencyOfIndex(index) {\n    assert(0 <= index && index < this.size, `index must be greater than or equal to 0 and less than ${this.size}`);\n    return index * this.context.sampleRate / (this.size * 2);\n  }\n}","map":{"version":3,"names":["ToneAudioNode","dbToGain","optionsFromArguments","MeterBase","assert","FFT","constructor","options","getDefaults","arguments","name","normalRange","_analyser","type","size","Object","assign","smoothing","getValue","values","map","v","val","getFrequencyOfIndex","index","context","sampleRate"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/component/analysis/FFT.ts"],"sourcesContent":["import { ToneAudioNode } from \"../../core/context/ToneAudioNode.js\";\nimport { dbToGain } from \"../../core/type/Conversions.js\";\nimport { Hertz, NormalRange, PowerOfTwo } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase.js\";\nimport { assert } from \"../../core/util/Debug.js\";\n\nexport interface FFTOptions extends MeterBaseOptions {\n\tsize: PowerOfTwo;\n\tsmoothing: NormalRange;\n\tnormalRange: boolean;\n}\n\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * Read more about FFT algorithms on [Wikipedia] (https://en.wikipedia.org/wiki/Fast_Fourier_transform).\n * @category Component\n */\nexport class FFT extends MeterBase<FFTOptions> {\n\treadonly name: string = \"FFT\";\n\n\t/**\n\t * If the output should be in decibels or normal range between 0-1. If `normalRange` is false,\n\t * the output range will be the measured decibel value, otherwise the decibel value will be converted to\n\t * the range of 0-1\n\t */\n\tnormalRange: boolean;\n\n\t/**\n\t * @param size The size of the FFT. Value must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(size?: PowerOfTwo);\n\tconstructor(options?: Partial<FFTOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(FFT.getDefaults(), arguments, [\n\t\t\t\"size\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis.normalRange = options.normalRange;\n\t\tthis._analyser.type = \"fft\";\n\t\tthis.size = options.size;\n\t}\n\n\tstatic getDefaults(): FFTOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tnormalRange: false,\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t});\n\t}\n\n\t/**\n\t * Gets the current frequency data from the connected audio source.\n\t * Returns the frequency data of length {@link size} as a Float32Array of decibel values.\n\t */\n\tgetValue(): Float32Array {\n\t\tconst values = this._analyser.getValue() as Float32Array;\n\t\treturn values.map((v) => (this.normalRange ? dbToGain(v) : v));\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t * Determines the size of the array returned by {@link getValue} (i.e. the number of\n\t * frequency bins). Large FFT sizes may be costly to compute.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.size;\n\t}\n\tset size(size) {\n\t\tthis._analyser.size = size;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analyser.smoothing;\n\t}\n\tset smoothing(val) {\n\t\tthis._analyser.smoothing = val;\n\t}\n\n\t/**\n\t * Returns the frequency value in hertz of each of the indices of the FFT's {@link getValue} response.\n\t * @example\n\t * const fft = new Tone.FFT(32);\n\t * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));\n\t */\n\tgetFrequencyOfIndex(index: number): Hertz {\n\t\tassert(\n\t\t\t0 <= index && index < this.size,\n\t\t\t`index must be greater than or equal to 0 and less than ${this.size}`\n\t\t);\n\t\treturn (index * this.context.sampleRate) / (this.size * 2);\n\t}\n}\n"],"mappings":"AAAA,SAASA,aAAa,QAAQ,qCAAqC;AACnE,SAASC,QAAQ,QAAQ,gCAAgC;AAEzD,SAASC,oBAAoB,QAAQ,6BAA6B;AAClE,SAASC,SAAS,QAA0B,gBAAgB;AAC5D,SAASC,MAAM,QAAQ,0BAA0B;AAQjD;;;;;AAKA,OAAM,MAAOC,GAAI,SAAQF,SAAqB;EAe7CG,YAAA;IACC,MAAMC,OAAO,GAAGL,oBAAoB,CAACG,GAAG,CAACG,WAAW,EAAE,EAAEC,SAAS,EAAE,CAClE,MAAM,CACN,CAAC;IACF,KAAK,CAACF,OAAO,CAAC;IAlBN,KAAAG,IAAI,GAAW,KAAK;IAoB5B,IAAI,CAACC,WAAW,GAAGJ,OAAO,CAACI,WAAW;IACtC,IAAI,CAACC,SAAS,CAACC,IAAI,GAAG,KAAK;IAC3B,IAAI,CAACC,IAAI,GAAGP,OAAO,CAACO,IAAI;EACzB;EAEA,OAAON,WAAWA,CAAA;IACjB,OAAOO,MAAM,CAACC,MAAM,CAAChB,aAAa,CAACQ,WAAW,EAAE,EAAE;MACjDG,WAAW,EAAE,KAAK;MAClBG,IAAI,EAAE,IAAI;MACVG,SAAS,EAAE;KACX,CAAC;EACH;EAEA;;;;EAIAC,QAAQA,CAAA;IACP,MAAMC,MAAM,GAAG,IAAI,CAACP,SAAS,CAACM,QAAQ,EAAkB;IACxD,OAAOC,MAAM,CAACC,GAAG,CAAEC,CAAC,IAAM,IAAI,CAACV,WAAW,GAAGV,QAAQ,CAACoB,CAAC,CAAC,GAAGA,CAAE,CAAC;EAC/D;EAEA;;;;;EAKA,IAAIP,IAAIA,CAAA;IACP,OAAO,IAAI,CAACF,SAAS,CAACE,IAAI;EAC3B;EACA,IAAIA,IAAIA,CAACA,IAAI;IACZ,IAAI,CAACF,SAAS,CAACE,IAAI,GAAGA,IAAI;EAC3B;EAEA;;;EAGA,IAAIG,SAASA,CAAA;IACZ,OAAO,IAAI,CAACL,SAAS,CAACK,SAAS;EAChC;EACA,IAAIA,SAASA,CAACK,GAAG;IAChB,IAAI,CAACV,SAAS,CAACK,SAAS,GAAGK,GAAG;EAC/B;EAEA;;;;;;EAMAC,mBAAmBA,CAACC,KAAa;IAChCpB,MAAM,CACL,CAAC,IAAIoB,KAAK,IAAIA,KAAK,GAAG,IAAI,CAACV,IAAI,EAC/B,0DAA0D,IAAI,CAACA,IAAI,EAAE,CACrE;IACD,OAAQU,KAAK,GAAG,IAAI,CAACC,OAAO,CAACC,UAAU,IAAK,IAAI,CAACZ,IAAI,GAAG,CAAC,CAAC;EAC3D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}