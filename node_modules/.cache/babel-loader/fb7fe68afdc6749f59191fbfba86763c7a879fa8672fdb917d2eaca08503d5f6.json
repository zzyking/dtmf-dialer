{"ast":null,"code":"import { Effect } from \"./Effect.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { WaveShaper } from \"../signal/WaveShaper.js\";\nimport { assert } from \"../core/util/Debug.js\";\n/**\n * Chebyshev is a waveshaper which is good\n * for making different types of distortion sounds.\n * Note that odd orders sound very different from even ones,\n * and order = 1 is no change.\n * Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).\n * @example\n * // create a new cheby\n * const cheby = new Tone.Chebyshev(50).toDestination();\n * // create a monosynth connected to our cheby\n * const synth = new Tone.MonoSynth().connect(cheby);\n * synth.triggerAttackRelease(\"C2\", 0.4);\n * @category Effect\n */\nexport class Chebyshev extends Effect {\n  constructor() {\n    const options = optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]);\n    super(options);\n    this.name = \"Chebyshev\";\n    this._shaper = new WaveShaper({\n      context: this.context,\n      length: 4096\n    });\n    this._order = options.order;\n    this.connectEffect(this._shaper);\n    this.order = options.order;\n    this.oversample = options.oversample;\n  }\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      order: 1,\n      oversample: \"none\"\n    });\n  }\n  /**\n   * get the coefficient for that degree\n   * @param  x the x value\n   * @param  degree\n   * @param  memo memoize the computed value. this speeds up computation greatly.\n   */\n  _getCoefficient(x, degree, memo) {\n    if (memo.has(degree)) {\n      return memo.get(degree);\n    } else if (degree === 0) {\n      memo.set(degree, 0);\n    } else if (degree === 1) {\n      memo.set(degree, x);\n    } else {\n      memo.set(degree, 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo));\n    }\n    return memo.get(degree);\n  }\n  /**\n   * The order of the Chebyshev polynomial which creates the equation which is applied to the incoming\n   * signal through a Tone.WaveShaper. Must be an integer. The equations are in the form:\n   * ```\n   * order 2: 2x^2 + 1\n   * order 3: 4x^3 + 3x\n   * ```\n   * @min 1\n   * @max 100\n   */\n  get order() {\n    return this._order;\n  }\n  set order(order) {\n    assert(Number.isInteger(order), \"'order' must be an integer\");\n    this._order = order;\n    this._shaper.setMap(x => {\n      return this._getCoefficient(x, order, new Map());\n    });\n  }\n  /**\n   * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n   */\n  get oversample() {\n    return this._shaper.oversample;\n  }\n  set oversample(oversampling) {\n    this._shaper.oversample = oversampling;\n  }\n  dispose() {\n    super.dispose();\n    this._shaper.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["Effect","optionsFromArguments","WaveShaper","assert","Chebyshev","constructor","options","getDefaults","arguments","name","_shaper","context","length","_order","order","connectEffect","oversample","Object","assign","_getCoefficient","x","degree","memo","has","get","set","Number","isInteger","setMap","Map","oversampling","dispose"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/effect/Chebyshev.ts"],"sourcesContent":["import { Effect, EffectOptions } from \"./Effect.js\";\nimport { Positive } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { WaveShaper } from \"../signal/WaveShaper.js\";\nimport { assert } from \"../core/util/Debug.js\";\n\nexport interface ChebyshevOptions extends EffectOptions {\n\torder: Positive;\n\toversample: OverSampleType;\n}\n\n/**\n * Chebyshev is a waveshaper which is good\n * for making different types of distortion sounds.\n * Note that odd orders sound very different from even ones,\n * and order = 1 is no change.\n * Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).\n * @example\n * // create a new cheby\n * const cheby = new Tone.Chebyshev(50).toDestination();\n * // create a monosynth connected to our cheby\n * const synth = new Tone.MonoSynth().connect(cheby);\n * synth.triggerAttackRelease(\"C2\", 0.4);\n * @category Effect\n */\nexport class Chebyshev extends Effect<ChebyshevOptions> {\n\treadonly name: string = \"Chebyshev\";\n\n\t/**\n\t * The private waveshaper node\n\t */\n\tprivate _shaper: WaveShaper;\n\n\t/**\n\t * holds onto the order of the filter\n\t */\n\tprivate _order: number;\n\n\t/**\n\t * @param order The order of the chebyshev polynomial. Normal range between 1-100.\n\t */\n\tconstructor(order?: Positive);\n\tconstructor(options?: Partial<ChebyshevOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tChebyshev.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"order\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._shaper = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 4096,\n\t\t});\n\t\tthis._order = options.order;\n\n\t\tthis.connectEffect(this._shaper);\n\t\tthis.order = options.order;\n\t\tthis.oversample = options.oversample;\n\t}\n\n\tstatic getDefaults(): ChebyshevOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\torder: 1,\n\t\t\toversample: \"none\" as const,\n\t\t});\n\t}\n\n\t/**\n\t * get the coefficient for that degree\n\t * @param  x the x value\n\t * @param  degree\n\t * @param  memo memoize the computed value. this speeds up computation greatly.\n\t */\n\tprivate _getCoefficient(\n\t\tx: number,\n\t\tdegree: number,\n\t\tmemo: Map<number, number>\n\t): number {\n\t\tif (memo.has(degree)) {\n\t\t\treturn memo.get(degree) as number;\n\t\t} else if (degree === 0) {\n\t\t\tmemo.set(degree, 0);\n\t\t} else if (degree === 1) {\n\t\t\tmemo.set(degree, x);\n\t\t} else {\n\t\t\tmemo.set(\n\t\t\t\tdegree,\n\t\t\t\t2 * x * this._getCoefficient(x, degree - 1, memo) -\n\t\t\t\t\tthis._getCoefficient(x, degree - 2, memo)\n\t\t\t);\n\t\t}\n\t\treturn memo.get(degree) as number;\n\t}\n\n\t/**\n\t * The order of the Chebyshev polynomial which creates the equation which is applied to the incoming\n\t * signal through a Tone.WaveShaper. Must be an integer. The equations are in the form:\n\t * ```\n\t * order 2: 2x^2 + 1\n\t * order 3: 4x^3 + 3x\n\t * ```\n\t * @min 1\n\t * @max 100\n\t */\n\tget order(): Positive {\n\t\treturn this._order;\n\t}\n\tset order(order) {\n\t\tassert(Number.isInteger(order), \"'order' must be an integer\");\n\t\tthis._order = order;\n\t\tthis._shaper.setMap((x) => {\n\t\t\treturn this._getCoefficient(x, order, new Map());\n\t\t});\n\t}\n\n\t/**\n\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\tset oversample(oversampling) {\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAuB,aAAa;AAEnD,SAASC,oBAAoB,QAAQ,0BAA0B;AAC/D,SAASC,UAAU,QAAQ,yBAAyB;AACpD,SAASC,MAAM,QAAQ,uBAAuB;AAO9C;;;;;;;;;;;;;;AAcA,OAAM,MAAOC,SAAU,SAAQJ,MAAwB;EAkBtDK,YAAA;IACC,MAAMC,OAAO,GAAGL,oBAAoB,CACnCG,SAAS,CAACG,WAAW,EAAE,EACvBC,SAAS,EACT,CAAC,OAAO,CAAC,CACT;IACD,KAAK,CAACF,OAAO,CAAC;IAvBN,KAAAG,IAAI,GAAW,WAAW;IAyBlC,IAAI,CAACC,OAAO,GAAG,IAAIR,UAAU,CAAC;MAC7BS,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBC,MAAM,EAAE;KACR,CAAC;IACF,IAAI,CAACC,MAAM,GAAGP,OAAO,CAACQ,KAAK;IAE3B,IAAI,CAACC,aAAa,CAAC,IAAI,CAACL,OAAO,CAAC;IAChC,IAAI,CAACI,KAAK,GAAGR,OAAO,CAACQ,KAAK;IAC1B,IAAI,CAACE,UAAU,GAAGV,OAAO,CAACU,UAAU;EACrC;EAEA,OAAOT,WAAWA,CAAA;IACjB,OAAOU,MAAM,CAACC,MAAM,CAAClB,MAAM,CAACO,WAAW,EAAE,EAAE;MAC1CO,KAAK,EAAE,CAAC;MACRE,UAAU,EAAE;KACZ,CAAC;EACH;EAEA;;;;;;EAMQG,eAAeA,CACtBC,CAAS,EACTC,MAAc,EACdC,IAAyB;IAEzB,IAAIA,IAAI,CAACC,GAAG,CAACF,MAAM,CAAC,EAAE;MACrB,OAAOC,IAAI,CAACE,GAAG,CAACH,MAAM,CAAW;IAClC,CAAC,MAAM,IAAIA,MAAM,KAAK,CAAC,EAAE;MACxBC,IAAI,CAACG,GAAG,CAACJ,MAAM,EAAE,CAAC,CAAC;IACpB,CAAC,MAAM,IAAIA,MAAM,KAAK,CAAC,EAAE;MACxBC,IAAI,CAACG,GAAG,CAACJ,MAAM,EAAED,CAAC,CAAC;IACpB,CAAC,MAAM;MACNE,IAAI,CAACG,GAAG,CACPJ,MAAM,EACN,CAAC,GAAGD,CAAC,GAAG,IAAI,CAACD,eAAe,CAACC,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEC,IAAI,CAAC,GAChD,IAAI,CAACH,eAAe,CAACC,CAAC,EAAEC,MAAM,GAAG,CAAC,EAAEC,IAAI,CAAC,CAC1C;IACF;IACA,OAAOA,IAAI,CAACE,GAAG,CAACH,MAAM,CAAW;EAClC;EAEA;;;;;;;;;;EAUA,IAAIP,KAAKA,CAAA;IACR,OAAO,IAAI,CAACD,MAAM;EACnB;EACA,IAAIC,KAAKA,CAACA,KAAK;IACdX,MAAM,CAACuB,MAAM,CAACC,SAAS,CAACb,KAAK,CAAC,EAAE,4BAA4B,CAAC;IAC7D,IAAI,CAACD,MAAM,GAAGC,KAAK;IACnB,IAAI,CAACJ,OAAO,CAACkB,MAAM,CAAER,CAAC,IAAI;MACzB,OAAO,IAAI,CAACD,eAAe,CAACC,CAAC,EAAEN,KAAK,EAAE,IAAIe,GAAG,EAAE,CAAC;IACjD,CAAC,CAAC;EACH;EAEA;;;EAGA,IAAIb,UAAUA,CAAA;IACb,OAAO,IAAI,CAACN,OAAO,CAACM,UAAU;EAC/B;EACA,IAAIA,UAAUA,CAACc,YAAY;IAC1B,IAAI,CAACpB,OAAO,CAACM,UAAU,GAAGc,YAAY;EACvC;EAEAC,OAAOA,CAAA;IACN,KAAK,CAACA,OAAO,EAAE;IACf,IAAI,CAACrB,OAAO,CAACqB,OAAO,EAAE;IACtB,OAAO,IAAI;EACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}