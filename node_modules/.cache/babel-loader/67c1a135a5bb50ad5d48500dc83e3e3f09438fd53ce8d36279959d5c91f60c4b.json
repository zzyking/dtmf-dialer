{"ast":null,"code":"import { ToneAudioNode } from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Split } from \"../channel/Split.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport { assert, assertRange } from \"../../core/util/Debug.js\";\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nexport class Analyser extends ToneAudioNode {\n  constructor() {\n    const options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n    super(options);\n    this.name = \"Analyser\";\n    /**\n     * The analyser node.\n     */\n    this._analysers = [];\n    /**\n     * The buffer that the FFT data is written to\n     */\n    this._buffers = [];\n    this.input = this.output = this._gain = new Gain({\n      context: this.context\n    });\n    this._split = new Split({\n      context: this.context,\n      channels: options.channels\n    });\n    this.input.connect(this._split);\n    assertRange(options.channels, 1);\n    // create the analysers\n    for (let channel = 0; channel < options.channels; channel++) {\n      this._analysers[channel] = this.context.createAnalyser();\n      this._split.connect(this._analysers[channel], channel, 0);\n    }\n    // set the values initially\n    this.size = options.size;\n    this.type = options.type;\n    this.smoothing = options.smoothing;\n  }\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      size: 1024,\n      smoothing: 0.8,\n      type: \"fft\",\n      channels: 1\n    });\n  }\n  /**\n   * Run the analysis given the current settings. If {@link channels} = 1,\n   * it will return a Float32Array. If {@link channels} > 1, it will\n   * return an array of Float32Arrays where each index in the array\n   * represents the analysis done on a channel.\n   */\n  getValue() {\n    this._analysers.forEach((analyser, index) => {\n      const buffer = this._buffers[index];\n      if (this._type === \"fft\") {\n        analyser.getFloatFrequencyData(buffer);\n      } else if (this._type === \"waveform\") {\n        analyser.getFloatTimeDomainData(buffer);\n      }\n    });\n    if (this.channels === 1) {\n      return this._buffers[0];\n    } else {\n      return this._buffers;\n    }\n  }\n  /**\n   * The size of analysis. This must be a power of two in the range 16 to 16384.\n   */\n  get size() {\n    return this._analysers[0].frequencyBinCount;\n  }\n  set size(size) {\n    this._analysers.forEach((analyser, index) => {\n      analyser.fftSize = size * 2;\n      this._buffers[index] = new Float32Array(size);\n    });\n  }\n  /**\n   * The number of channels the analyser does the analysis on. Channel\n   * separation is done using {@link Split}\n   */\n  get channels() {\n    return this._analysers.length;\n  }\n  /**\n   * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n   */\n  get type() {\n    return this._type;\n  }\n  set type(type) {\n    assert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n    this._type = type;\n  }\n  /**\n   * 0 represents no time averaging with the last analysis frame.\n   */\n  get smoothing() {\n    return this._analysers[0].smoothingTimeConstant;\n  }\n  set smoothing(val) {\n    this._analysers.forEach(a => a.smoothingTimeConstant = val);\n  }\n  /**\n   * Clean up.\n   */\n  dispose() {\n    super.dispose();\n    this._analysers.forEach(a => a.disconnect());\n    this._split.dispose();\n    this._gain.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["ToneAudioNode","optionsFromArguments","Split","Gain","assert","assertRange","Analyser","constructor","options","getDefaults","arguments","name","_analysers","_buffers","input","output","_gain","context","_split","channels","connect","channel","createAnalyser","size","type","smoothing","Object","assign","getValue","forEach","analyser","index","buffer","_type","getFloatFrequencyData","getFloatTimeDomainData","frequencyBinCount","fftSize","Float32Array","length","smoothingTimeConstant","val","a","dispose","disconnect"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/component/analysis/Analyser.ts"],"sourcesContent":["import {\n\tInputNode,\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { NormalRange, PowerOfTwo } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Split } from \"../channel/Split.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport { assert, assertRange } from \"../../core/util/Debug.js\";\n\nexport type AnalyserType = \"fft\" | \"waveform\";\n\nexport interface AnalyserOptions extends ToneAudioNodeOptions {\n\tsize: PowerOfTwo;\n\ttype: AnalyserType;\n\tsmoothing: NormalRange;\n\tchannels: number;\n}\n\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nexport class Analyser extends ToneAudioNode<AnalyserOptions> {\n\treadonly name: string = \"Analyser\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The analyser node.\n\t */\n\tprivate _analysers: AnalyserNode[] = [];\n\n\t/**\n\t * Input and output are a gain node\n\t */\n\tprivate _gain: Gain;\n\n\t/**\n\t * The channel splitter node\n\t */\n\tprivate _split: Split;\n\n\t/**\n\t * The analysis type\n\t */\n\tprivate _type!: AnalyserType;\n\n\t/**\n\t * The buffer that the FFT data is written to\n\t */\n\tprivate _buffers: Float32Array[] = [];\n\n\t/**\n\t * @param type The return type of the analysis, either \"fft\", or \"waveform\".\n\t * @param size The size of the FFT. This must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(type?: AnalyserType, size?: number);\n\tconstructor(options?: Partial<AnalyserOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tAnalyser.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"type\", \"size\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.input =\n\t\t\tthis.output =\n\t\t\tthis._gain =\n\t\t\t\tnew Gain({ context: this.context });\n\t\tthis._split = new Split({\n\t\t\tcontext: this.context,\n\t\t\tchannels: options.channels,\n\t\t});\n\t\tthis.input.connect(this._split);\n\n\t\tassertRange(options.channels, 1);\n\n\t\t// create the analysers\n\t\tfor (let channel = 0; channel < options.channels; channel++) {\n\t\t\tthis._analysers[channel] = this.context.createAnalyser();\n\t\t\tthis._split.connect(this._analysers[channel], channel, 0);\n\t\t}\n\n\t\t// set the values initially\n\t\tthis.size = options.size;\n\t\tthis.type = options.type;\n\t\tthis.smoothing = options.smoothing;\n\t}\n\n\tstatic getDefaults(): AnalyserOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t\ttype: \"fft\" as AnalyserType,\n\t\t\tchannels: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Run the analysis given the current settings. If {@link channels} = 1,\n\t * it will return a Float32Array. If {@link channels} > 1, it will\n\t * return an array of Float32Arrays where each index in the array\n\t * represents the analysis done on a channel.\n\t */\n\tgetValue(): Float32Array | Float32Array[] {\n\t\tthis._analysers.forEach((analyser, index) => {\n\t\t\tconst buffer = this._buffers[index];\n\t\t\tif (this._type === \"fft\") {\n\t\t\t\tanalyser.getFloatFrequencyData(buffer);\n\t\t\t} else if (this._type === \"waveform\") {\n\t\t\t\tanalyser.getFloatTimeDomainData(buffer);\n\t\t\t}\n\t\t});\n\t\tif (this.channels === 1) {\n\t\t\treturn this._buffers[0];\n\t\t} else {\n\t\t\treturn this._buffers;\n\t\t}\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analysers[0].frequencyBinCount;\n\t}\n\tset size(size: PowerOfTwo) {\n\t\tthis._analysers.forEach((analyser, index) => {\n\t\t\tanalyser.fftSize = size * 2;\n\t\t\tthis._buffers[index] = new Float32Array(size);\n\t\t});\n\t}\n\n\t/**\n\t * The number of channels the analyser does the analysis on. Channel\n\t * separation is done using {@link Split}\n\t */\n\tget channels(): number {\n\t\treturn this._analysers.length;\n\t}\n\n\t/**\n\t * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n\t */\n\tget type(): AnalyserType {\n\t\treturn this._type;\n\t}\n\tset type(type: AnalyserType) {\n\t\tassert(\n\t\t\ttype === \"waveform\" || type === \"fft\",\n\t\t\t`Analyser: invalid type: ${type}`\n\t\t);\n\t\tthis._type = type;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analysers[0].smoothingTimeConstant;\n\t}\n\tset smoothing(val: NormalRange) {\n\t\tthis._analysers.forEach((a) => (a.smoothingTimeConstant = val));\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analysers.forEach((a) => a.disconnect());\n\t\tthis._split.dispose();\n\t\tthis._gain.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}