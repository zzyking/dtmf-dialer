{"ast":null,"code":"import { StereoXFeedbackEffect } from \"./StereoXFeedbackEffect.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Delay } from \"../core/context/Delay.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n/**\n * PingPongDelay is a feedback delay effect where the echo is heard\n * first in one channel and next in the opposite channel. In a stereo\n * system these are the right and left channels.\n * PingPongDelay in more simplified terms is two Tone.FeedbackDelays\n * with independent delay values. Each delay is routed to one channel\n * (left or right), and the channel triggered second will always\n * trigger at the same interval after the first.\n * @example\n * const pingPong = new Tone.PingPongDelay(\"4n\", 0.2).toDestination();\n * const drum = new Tone.MembraneSynth().connect(pingPong);\n * drum.triggerAttackRelease(\"C4\", \"32n\");\n * @category Effect\n */\nexport class PingPongDelay extends StereoXFeedbackEffect {\n  constructor() {\n    const options = optionsFromArguments(PingPongDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n    super(options);\n    this.name = \"PingPongDelay\";\n    this._leftDelay = new Delay({\n      context: this.context,\n      maxDelay: options.maxDelay\n    });\n    this._rightDelay = new Delay({\n      context: this.context,\n      maxDelay: options.maxDelay\n    });\n    this._rightPreDelay = new Delay({\n      context: this.context,\n      maxDelay: options.maxDelay\n    });\n    this.delayTime = new Signal({\n      context: this.context,\n      units: \"time\",\n      value: options.delayTime\n    });\n    // connect it up\n    this.connectEffectLeft(this._leftDelay);\n    this.connectEffectRight(this._rightPreDelay, this._rightDelay);\n    this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);\n    // rearranged the feedback to be after the rightPreDelay\n    this._feedbackL.disconnect();\n    this._feedbackL.connect(this._rightDelay);\n    readOnly(this, [\"delayTime\"]);\n  }\n  static getDefaults() {\n    return Object.assign(StereoXFeedbackEffect.getDefaults(), {\n      delayTime: 0.25,\n      maxDelay: 1\n    });\n  }\n  dispose() {\n    super.dispose();\n    this._leftDelay.dispose();\n    this._rightDelay.dispose();\n    this._rightPreDelay.dispose();\n    this.delayTime.dispose();\n    return this;\n  }\n}","map":{"version":3,"names":["StereoXFeedbackEffect","optionsFromArguments","Delay","Signal","readOnly","PingPongDelay","constructor","options","getDefaults","arguments","name","_leftDelay","context","maxDelay","_rightDelay","_rightPreDelay","delayTime","units","value","connectEffectLeft","connectEffectRight","fan","_feedbackL","disconnect","connect","Object","assign","dispose"],"sources":["/Users/king/Documents/GitHub/dtmf-dialer/node_modules/tone/Tone/effect/PingPongDelay.ts"],"sourcesContent":["import {\n\tStereoXFeedbackEffect,\n\tStereoXFeedbackEffectOptions,\n} from \"./StereoXFeedbackEffect.js\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Delay } from \"../core/context/Delay.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n\nexport interface PingPongDelayOptions extends StereoXFeedbackEffectOptions {\n\tdelayTime: Time;\n\tmaxDelay: Seconds;\n}\n\n/**\n * PingPongDelay is a feedback delay effect where the echo is heard\n * first in one channel and next in the opposite channel. In a stereo\n * system these are the right and left channels.\n * PingPongDelay in more simplified terms is two Tone.FeedbackDelays\n * with independent delay values. Each delay is routed to one channel\n * (left or right), and the channel triggered second will always\n * trigger at the same interval after the first.\n * @example\n * const pingPong = new Tone.PingPongDelay(\"4n\", 0.2).toDestination();\n * const drum = new Tone.MembraneSynth().connect(pingPong);\n * drum.triggerAttackRelease(\"C4\", \"32n\");\n * @category Effect\n */\nexport class PingPongDelay extends StereoXFeedbackEffect<PingPongDelayOptions> {\n\treadonly name: string = \"PingPongDelay\";\n\n\t/**\n\t * the delay node on the left side\n\t */\n\tprivate _leftDelay: Delay;\n\n\t/**\n\t * the delay node on the right side\n\t */\n\tprivate _rightDelay: Delay;\n\n\t/**\n\t * the predelay on the right side\n\t */\n\tprivate _rightPreDelay: Delay;\n\n\t/**\n\t * the delay time signal\n\t */\n\treadonly delayTime: Signal<\"time\">;\n\n\t/**\n\t * @param delayTime The delayTime between consecutive echos.\n\t * @param feedback The amount of the effected signal which is fed back through the delay.\n\t */\n\tconstructor(delayTime?: Time, feedback?: NormalRange);\n\tconstructor(options?: Partial<PingPongDelayOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tPingPongDelay.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"delayTime\", \"feedback\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._leftDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis._rightDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis._rightPreDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis.delayTime = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.delayTime,\n\t\t});\n\n\t\t// connect it up\n\t\tthis.connectEffectLeft(this._leftDelay);\n\t\tthis.connectEffectRight(this._rightPreDelay, this._rightDelay);\n\t\tthis.delayTime.fan(\n\t\t\tthis._leftDelay.delayTime,\n\t\t\tthis._rightDelay.delayTime,\n\t\t\tthis._rightPreDelay.delayTime\n\t\t);\n\t\t// rearranged the feedback to be after the rightPreDelay\n\t\tthis._feedbackL.disconnect();\n\t\tthis._feedbackL.connect(this._rightDelay);\n\t\treadOnly(this, [\"delayTime\"]);\n\t}\n\n\tstatic getDefaults(): PingPongDelayOptions {\n\t\treturn Object.assign(StereoXFeedbackEffect.getDefaults(), {\n\t\t\tdelayTime: 0.25,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._leftDelay.dispose();\n\t\tthis._rightDelay.dispose();\n\t\tthis._rightPreDelay.dispose();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n"],"mappings":"AAAA,SACCA,qBAAqB,QAEf,4BAA4B;AAEnC,SAASC,oBAAoB,QAAQ,0BAA0B;AAC/D,SAASC,KAAK,QAAQ,0BAA0B;AAChD,SAASC,MAAM,QAAQ,qBAAqB;AAC5C,SAASC,QAAQ,QAAQ,2BAA2B;AAOpD;;;;;;;;;;;;;;AAcA,OAAM,MAAOC,aAAc,SAAQL,qBAA2C;EA6B7EM,YAAA;IACC,MAAMC,OAAO,GAAGN,oBAAoB,CACnCI,aAAa,CAACG,WAAW,EAAE,EAC3BC,SAAS,EACT,CAAC,WAAW,EAAE,UAAU,CAAC,CACzB;IACD,KAAK,CAACF,OAAO,CAAC;IAlCN,KAAAG,IAAI,GAAW,eAAe;IAoCtC,IAAI,CAACC,UAAU,GAAG,IAAIT,KAAK,CAAC;MAC3BU,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBC,QAAQ,EAAEN,OAAO,CAACM;KAClB,CAAC;IACF,IAAI,CAACC,WAAW,GAAG,IAAIZ,KAAK,CAAC;MAC5BU,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBC,QAAQ,EAAEN,OAAO,CAACM;KAClB,CAAC;IACF,IAAI,CAACE,cAAc,GAAG,IAAIb,KAAK,CAAC;MAC/BU,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBC,QAAQ,EAAEN,OAAO,CAACM;KAClB,CAAC;IACF,IAAI,CAACG,SAAS,GAAG,IAAIb,MAAM,CAAC;MAC3BS,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBK,KAAK,EAAE,MAAM;MACbC,KAAK,EAAEX,OAAO,CAACS;KACf,CAAC;IAEF;IACA,IAAI,CAACG,iBAAiB,CAAC,IAAI,CAACR,UAAU,CAAC;IACvC,IAAI,CAACS,kBAAkB,CAAC,IAAI,CAACL,cAAc,EAAE,IAAI,CAACD,WAAW,CAAC;IAC9D,IAAI,CAACE,SAAS,CAACK,GAAG,CACjB,IAAI,CAACV,UAAU,CAACK,SAAS,EACzB,IAAI,CAACF,WAAW,CAACE,SAAS,EAC1B,IAAI,CAACD,cAAc,CAACC,SAAS,CAC7B;IACD;IACA,IAAI,CAACM,UAAU,CAACC,UAAU,EAAE;IAC5B,IAAI,CAACD,UAAU,CAACE,OAAO,CAAC,IAAI,CAACV,WAAW,CAAC;IACzCV,QAAQ,CAAC,IAAI,EAAE,CAAC,WAAW,CAAC,CAAC;EAC9B;EAEA,OAAOI,WAAWA,CAAA;IACjB,OAAOiB,MAAM,CAACC,MAAM,CAAC1B,qBAAqB,CAACQ,WAAW,EAAE,EAAE;MACzDQ,SAAS,EAAE,IAAI;MACfH,QAAQ,EAAE;KACV,CAAC;EACH;EAEAc,OAAOA,CAAA;IACN,KAAK,CAACA,OAAO,EAAE;IACf,IAAI,CAAChB,UAAU,CAACgB,OAAO,EAAE;IACzB,IAAI,CAACb,WAAW,CAACa,OAAO,EAAE;IAC1B,IAAI,CAACZ,cAAc,CAACY,OAAO,EAAE;IAC7B,IAAI,CAACX,SAAS,CAACW,OAAO,EAAE;IACxB,OAAO,IAAI;EACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}